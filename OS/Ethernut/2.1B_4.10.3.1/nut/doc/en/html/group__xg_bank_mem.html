<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nut/OS: Banked Memory</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="nutos_logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nut/OS
   &#160;<span id="projectnumber">4.10.3</span>
   </div>
   <div id="projectbrief">API Reference</div>
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__xg_bank_mem.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Banked Memory</div>  </div>
<div class="ingroups"><a class="el" href="group__xg_app_sugar.html">Application Candies</a></div></div>
<div class="contents">

<p>Banked RAM support.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Banked Memory:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__xg_bank_mem.png" border="0" alt="" usemap="#group____xg__bank__mem"/>
<map name="group____xg__bank__mem" id="group____xg__bank__mem">
<area shape="rect" id="node1" href="group__xg_app_sugar.html" title="In order to keep the kernel clean and small, it uses very basic functions only:" alt="" coords="6,5,138,30"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ga59e6535d66539f29aed5909eb0b70eed">NutSegBufReset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the segmented buffer.  <a href="#ga59e6535d66539f29aed5909eb0b70eed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ga54b4fc4de72531a2c413219187019e71">NutSegBufInit</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the segmented buffer.  <a href="#ga54b4fc4de72531a2c413219187019e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ga5dca6c51548e7ee90dc79cddaa1668fd">NutSegBufWriteRequest</a> (size_t *bcp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request segmented buffer space for writing.  <a href="#ga5dca6c51548e7ee90dc79cddaa1668fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gac9fb2d54037da348dfc6a9c99b47e75f">NutSegBufReadRequest</a> (size_t *bcp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request segmented buffer space for reading.  <a href="#gac9fb2d54037da348dfc6a9c99b47e75f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gae7d02ba9e852fc6bde683efb8da33769">NutSegBufWriteCommit</a> (size_t bc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit written buffer space.  <a href="#gae7d02ba9e852fc6bde683efb8da33769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ga285f080acdb4ed3074e24387c179f76b">NutSegBufReadCommit</a> (size_t bc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit read buffer space.  <a href="#ga285f080acdb4ed3074e24387c179f76b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ga435c70799400cd3fab9b305d9e83987c">NutSegBufWriteLast</a> (size_t bc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit written buffer space and finish write access.  <a href="#ga435c70799400cd3fab9b305d9e83987c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gad9e27e0283495409f46e25e794286b4b">NutSegBufReadLast</a> (size_t bc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit written buffer space and finish read access.  <a href="#gad9e27e0283495409f46e25e794286b4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ga866d595bca99894fdee0e1e59cdc5d7d">NutSegBufAvailable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the available buffer space.  <a href="#ga866d595bca99894fdee0e1e59cdc5d7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gacc5a7121fca5d27017c4d9f851a90475">NutSegBufUsed</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the used buffer space.  <a href="#gacc5a7121fca5d27017c4d9f851a90475"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Banked RAM support. </p>
<p>Even with a hardware decoder like the one used on the Medianut Board, streaming MP3 data in realtime from a TCP/IP network to the decoder requires some special techniques to make it work on a tiny 8 bit system.</p>
<p>The key to success is avoidance of data copying. Usually data streams are moved from the Ethernet Controller to the Ethernet's driver buffer, then moved to the TCP buffer, again moved to the application buffer and finally from the application buffer to the MP3 decoder buffer. Some systems may use additional steps. Nut/OS tries to avoid these copies. In extreme, the data may be moved directly from the Ethernet controller to the MP3 controller. In reality this will fail, because TCP isn't realtime, but playing MP3 is. So at least one buffer stage is required to compensate the non deterministic arrival of TCP data. Each packet received is moved from the Ethernet controller into a so called NETBUF. Each NETBUF is added to a connection specific queue until the application request data from the connection. For portability reasons and to keep things simple, the application provides a buffer and calls <a class="el" href="group__xg_tcp_socket.html#gab08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive()</a> to get that buffer filled with application data out of the queued NETBUFs. This is another copy, but frees the application from dealing with system specific NETBUF structures.</p>
<p>The smart part is, that Nut/OS offers a special buffer management to avoid the final copy into the decoder buffer and that the Nut/OS MP3 decoder driver makes use of this buffer management. As stated, normally the application buffer is filled by some kind of read statement (first copy) and transfered to the driver by some kind of write statement (second copy).</p>
<p>When using the segmented memory management, the application will query the driver for buffer space first and then pass this buffer to the TCP read routine. This way the TCP read routine will directly fill the buffer of the decoder driver. When this has been done, the application commits the buffer filled and requests a new one and so on.</p>
<p>Finally the segmented memory mamagement API can not only handle a continuos memory space, but also one that is divided into several segments. This is usefull with banked memory hardware provided by Ethernut 2 boards.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>At least some parts should be moved to the device section. </dd></dl>
<p>$Log$ Revision 1.7 2009/02/06 15:40:29 haraldkipp Using newly available <a class="el" href="group__xg_crt_string.html#ga608db5821b635f6a719ecb7f76d4a5da" title="Create a copy of a string.">strdup()</a> and <a class="el" href="icc_8h.html#a84beef8cc122add35118ec7cd35286c4">calloc()</a>. Replaced NutHeap routines by standard malloc/free. Replaced pointer value 0 by NULL.</p>
<p>Revision 1.6 2008/08/11 07:00:33 haraldkipp BSD types replaced by stdint types (feature request #1282721).</p>
<p>Revision 1.5 2008/02/15 17:08:05 haraldkipp Calling the initialization routine more than once is now possible. By default, half of the available memory will be allocated. Previous versions eat all free memory but 8k.</p>
<p>Revision 1.4 2007/04/12 09:08:57 haraldkipp Segmented buffer routines ported to ARM.</p>
<p>Revision 1.3 2004/12/17 15:28:33 haraldkipp Bugfix. Comparison of the read and write pointers now includes the segments. Thanks to Pete Allinson and Johan van der Stoel.</p>
<p>Revision 1.2 2004/08/18 18:51:56 haraldkipp Made banked memory configurable.</p>
<p>Revision 1.1 2003/07/21 18:19:48 haraldkipp First check in </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga59e6535d66539f29aed5909eb0b70eed"></a><!-- doxytag: member="bankmem.c::NutSegBufReset" ref="ga59e6535d66539f29aed5909eb0b70eed" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the segmented buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the first buffer segment. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00094">94</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c_source.html#l00266">FeederThread()</a>, <a class="el" href="bankmem_8c_source.html#l00117">NutSegBufInit()</a>, and <a class="el" href="spi__vscodec_8c_source.html#l00877">VsCodecOpen()</a>.</p>

</div>
</div>
<a class="anchor" id="ga54b4fc4de72531a2c413219187019e71"></a><!-- doxytag: member="bankmem.c::NutSegBufInit" ref="ga54b4fc4de72531a2c413219187019e71" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufInit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the segmented buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of bytes to allocate for the global buffer. In systems with banked memory this parameter is ignored and all banked memory is occupied for the global buffer. In systems without banked memory, the specified number of bytes is taken from heap memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the first buffer segment or null on failures. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00117">117</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h_source.html#l00106">NUTBANK_COUNT</a>, <a class="el" href="memory_8h_source.html#l00124">NUTBANK_SIZE</a>, <a class="el" href="memory_8h_source.html#l00115">NUTBANK_START</a>, <a class="el" href="heap_8h_source.html#l00086">NutHeapAlloc</a>, <a class="el" href="heap_8h_source.html#l00077">NutHeapAvailable</a>, <a class="el" href="heap_8h_source.html#l00088">NutHeapFree</a>, and <a class="el" href="bankmem_8c_source.html#l00094">NutSegBufReset()</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c_source.html#l00315">VsDecoderBufferInit()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__xg_bank_mem_ga54b4fc4de72531a2c413219187019e71_cgraph.png" border="0" usemap="#group__xg_bank_mem_ga54b4fc4de72531a2c413219187019e71_cgraph" alt=""/></div>
<map name="group__xg_bank_mem_ga54b4fc4de72531a2c413219187019e71_cgraph" id="group__xg_bank_mem_ga54b4fc4de72531a2c413219187019e71_cgraph">
<area shape="rect" id="node3" href="group__xg_bank_mem.html#ga59e6535d66539f29aed5909eb0b70eed" title="Reset the segmented buffer." alt="" coords="152,5,267,30"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga5dca6c51548e7ee90dc79cddaa1668fd"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteRequest" ref="ga5dca6c51548e7ee90dc79cddaa1668fd" args="(size_t *bcp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufWriteRequest </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request segmented buffer space for writing. </p>
<p>This call will also enable the current write segment and may disable the current read segment.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bcp</td><td>Pointer to a variable, which receives the number of consecutive bytes available for writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the next write position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00150">150</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c_source.html#l00337">FeederThread()</a>, and <a class="el" href="spi__vscodec_8c_source.html#l00809">VsCodecWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="gac9fb2d54037da348dfc6a9c99b47e75f"></a><!-- doxytag: member="bankmem.c::NutSegBufReadRequest" ref="gac9fb2d54037da348dfc6a9c99b47e75f" args="(size_t *bcp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufReadRequest </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request segmented buffer space for reading. </p>
<p>This call will also enable the current read segment and may disable the current write segment.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bcp</td><td>Pointer to a variable, which receives the number of consecutive bytes available for reading.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the next read position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00173">173</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c_source.html#l00266">FeederThread()</a>, and <a class="el" href="spi__vscodec_8c_source.html#l00746">VsCodecRead()</a>.</p>

</div>
</div>
<a class="anchor" id="gae7d02ba9e852fc6bde683efb8da33769"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteCommit" ref="gae7d02ba9e852fc6bde683efb8da33769" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufWriteCommit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit written buffer space. </p>
<p>The write pointer will be incremented by the specified number of bytes. If the pointer reaches the end of a segment, the next segment will be enabled and the pointer will point to the start of the new segement.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bc</td><td>Number of bytes to commit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the next write position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00197">197</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h_source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

</div>
</div>
<a class="anchor" id="ga285f080acdb4ed3074e24387c179f76b"></a><!-- doxytag: member="bankmem.c::NutSegBufReadCommit" ref="ga285f080acdb4ed3074e24387c179f76b" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufReadCommit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit read buffer space. </p>
<p>The read pointer will be incremented by the specified number of bytes. If the pointer reaches the end of a segment, the next segment will be enabled and the pointer will point to the start of the new segement.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bc</td><td>Number of bytes to commit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the next read position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00226">226</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h_source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

</div>
</div>
<a class="anchor" id="ga435c70799400cd3fab9b305d9e83987c"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteLast" ref="ga435c70799400cd3fab9b305d9e83987c" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutSegBufWriteLast </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit written buffer space and finish write access. </p>
<p>The write pointer will be incremented by the specified number of bytes. This call will also enable the current read segment and may disable the current write segment.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bc</td><td>Number of bytes to commit. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00255">255</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h_source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c_source.html#l00337">FeederThread()</a>, and <a class="el" href="spi__vscodec_8c_source.html#l00809">VsCodecWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="gad9e27e0283495409f46e25e794286b4b"></a><!-- doxytag: member="bankmem.c::NutSegBufReadLast" ref="gad9e27e0283495409f46e25e794286b4b" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutSegBufReadLast </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit written buffer space and finish read access. </p>
<p>The write pointer will be incremented by the specified number of bytes. This call will also enable the current read segment and may disable the current write segment.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bc</td><td>Number of bytes to commit. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00281">281</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h_source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h_source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c_source.html#l00266">FeederThread()</a>, and <a class="el" href="spi__vscodec_8c_source.html#l00746">VsCodecRead()</a>.</p>

</div>
</div>
<a class="anchor" id="ga866d595bca99894fdee0e1e59cdc5d7d"></a><!-- doxytag: member="bankmem.c::NutSegBufAvailable" ref="ga866d595bca99894fdee0e1e59cdc5d7d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> NutSegBufAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the available buffer space. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total number of free bytes in the buffer. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00305">305</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c_source.html#l00577">VsCodecIOCtl()</a>, and <a class="el" href="spi__vscodec_8c_source.html#l00315">VsDecoderBufferInit()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc5a7121fca5d27017c4d9f851a90475"></a><!-- doxytag: member="bankmem.c::NutSegBufUsed" ref="gacc5a7121fca5d27017c4d9f851a90475" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> NutSegBufUsed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the used buffer space. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total number of used bytes in the buffer. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c_source.html#l00315">315</a> of file <a class="el" href="bankmem_8c_source.html">bankmem.c</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c_source.html#l00266">FeederThread()</a>, <a class="el" href="spi__vscodec_8c_source.html#l00577">VsCodecIOCtl()</a>, and <a class="el" href="vs1001k_8c_source.html#l00760">VsPlayerFlush()</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr>
<address>
  <small>
    &copy;&nbsp;2000-2010 by contributors - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
