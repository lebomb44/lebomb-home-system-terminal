<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
    <link href="nut_entabs.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>TCP Sockets<br>
<small>
[<a class="el" href="group__xg_socket.html">Socket API</a>]</small>
</h1>Application interface for TCP sockets.  
<a href="#_details">More...</a>
<p>

<p>
<div class="dynheader">
Collaboration diagram for TCP Sockets:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__xg_tcp_socket.png" border="0" alt="" usemap="#group____xg__tcp__socket_map">
<map name="group____xg__tcp__socket_map">
<area shape="rect" href="group__xg_socket.html" title="Nut/Net Socket Interface." alt="Socket API" coords="19,5,96,26"></map></td></tr></table></center>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp__socket.html">TCPSOCKET</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TCP socket information structure.  <a href="structtcp__socket.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gefdf0c5749674efdd40a37857ca45f78">SO_FIN</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Send FIN after all data has been transmitted.  <a href="#gefdf0c5749674efdd40a37857ca45f78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g4a15c49046e1b3c0c3b4a3fad2b55c6c">SO_SYN</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Send SYN first.  <a href="#g4a15c49046e1b3c0c3b4a3fad2b55c6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g070f5c81fc9c6442a0576f42d67c794c">SO_FORCE</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Force sending ACK.  <a href="#g070f5c81fc9c6442a0576f42d67c794c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gb60d40db730ce72950328301beae2c1c">SO_ACK</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket transmit flag. Send ACK.  <a href="#gb60d40db730ce72950328301beae2c1c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#ge062b546a18e3a15d4fa87209d6160ca">NutTcpDiscardBuffers</a> (TCPSOCKET *sock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g551224f0a840a9cbf97b4d49dbc7c018">NutTcpDestroySocket</a> (TCPSOCKET *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a previously allocated socket.  <a href="#g551224f0a840a9cbf97b4d49dbc7c018"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TCPSOCKET *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g376cfd10344a38e74cde7ee2667ae3fe">NutTcpFindSocket</a> (<a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> lport, <a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> rport, <a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> raddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a matching socket.  <a href="#g376cfd10344a38e74cde7ee2667ae3fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TCPSOCKET *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6">NutTcpCreateSocket</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a TCP socket.  <a href="#g6bf8ec59828c5a0e38423293b4dfe8e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gb3bd1c81e2046e53cde6973b9c6bf6f4">NutTcpSetSockOpt</a> (TCPSOCKET *sock, int optname, CONST void *optval, int optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set value of a TCP socket option.  <a href="#gb3bd1c81e2046e53cde6973b9c6bf6f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g357055ae6ebc31de5dd3e85ebd132108">NutTcpGetSockOpt</a> (TCPSOCKET *sock, int optname, void *optval, int optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a TCP socket option value.  <a href="#g357055ae6ebc31de5dd3e85ebd132108"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g48ff1e877483a0833cf38e428eac6457">NutTcpConnect</a> (TCPSOCKET *sock, <a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> addr, <a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a remote socket.  <a href="#g48ff1e877483a0833cf38e428eac6457"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g3859b3c38665aedc32608827f931498a">NutTcpAccept</a> (TCPSOCKET *sock, <a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for incoming connect from a remote socket.  <a href="#g3859b3c38665aedc32608827f931498a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gfc14dd4c910afbb9269adc5bebba0281">NutTcpSend</a> (TCPSOCKET *sock, CONST void *data, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send data on a connected TCP socket.  <a href="#gfc14dd4c910afbb9269adc5bebba0281"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa">NutTcpReceive</a> (TCPSOCKET *sock, void *data, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data on a connected TCP socket.  <a href="#gb08d3e50fd09da18b966af0dd23fa4aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g09d94fd887683a0837e06c2cc08fc7ba">NutTcpCloseSocket</a> (TCPSOCKET *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close TCP socket.  <a href="#g09d94fd887683a0837e06c2cc08fc7ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255">NutTcpError</a> (TCPSOCKET *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return specific code of the last error.  <a href="#g3953f713369f008979d738b32d8fc255"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gc4ab675d039b53314b37b12b70afefd5">NutTcpDeviceRead</a> (TCPSOCKET *sock, void *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from virtual socket device.  <a href="#gc4ab675d039b53314b37b12b70afefd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g9e0cdc2012de837e6b81006b9b32ca12">NutTcpDeviceWrite</a> (TCPSOCKET *sock, CONST void *buf, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a socket.  <a href="#g9e0cdc2012de837e6b81006b9b32ca12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g71f2a257f72723170c19ad7b5d9f991f">NutTcpDeviceWrite_P</a> (TCPSOCKET *sock, PGM_P buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to device.  <a href="#g71f2a257f72723170c19ad7b5d9f991f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#gceb6b4b842cb85f48f6ca163c7aa1ce0">NutTcpDeviceIOCtl</a> (TCPSOCKET *sock, int cmd, void *param)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Driver control function.  <a href="#gceb6b4b842cb85f48f6ca163c7aa1ce0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TCPSOCKET *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_tcp_socket.html#g2fcec3521061173b7bdd704877a57395">tcpSocketList</a> = 0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Application interface for TCP sockets. 
<p>
TCP clients typically use this order of API calls<ul>
<li><a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a></li><li><a class="el" href="group__xg_tcp_socket.html#g48ff1e877483a0833cf38e428eac6457" title="Connect to a remote socket.">NutTcpConnect()</a></li><li><a class="el" href="group__xg_tcp_socket.html#gfc14dd4c910afbb9269adc5bebba0281" title="Send data on a connected TCP socket.">NutTcpSend()</a>, <a class="el" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive()</a></li><li><a class="el" href="group__xg_tcp_socket.html#g09d94fd887683a0837e06c2cc08fc7ba" title="Close TCP socket.">NutTcpCloseSocket()</a></li></ul>
<p>
This is quite similar to the traditional Berkley TCP Socket API used on desktop PCs.<p>
The order of API calls for TCP servers is<ul>
<li><a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a></li><li><a class="el" href="group__xg_tcp_socket.html#g3859b3c38665aedc32608827f931498a" title="Wait for incoming connect from a remote socket.">NutTcpAccept()</a></li><li><a class="el" href="group__xg_tcp_socket.html#gfc14dd4c910afbb9269adc5bebba0281" title="Send data on a connected TCP socket.">NutTcpSend()</a>, <a class="el" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive()</a></li><li><a class="el" href="group__xg_tcp_socket.html#g09d94fd887683a0837e06c2cc08fc7ba" title="Close TCP socket.">NutTcpCloseSocket()</a></li></ul>
<p>
Note, that this differs slightly from the Berkley API, where the initial socket is bound to a port and an additional socket is created when a connection is accepted. Nut/Net doesn't provide a bind call.<p>
Most Nut/OS applications make use of the ability to assign a TCP socket to a stream and replace the somewhat primitive functions <a class="el" href="group__xg_tcp_socket.html#gfc14dd4c910afbb9269adc5bebba0281" title="Send data on a connected TCP socket.">NutTcpSend()</a> and <a class="el" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive()</a> with stdio calls like <a class="el" href="group__xg_crt_stdio.html#g2f7351ee13f3f4c465c65e849a12a3fd" title="Print formatted data to a stream.">fprintf()</a> or <a class="el" href="group__xg_crt_stdio.html#g344a4094f900770fa0c5c1c80054dbda" title="Read formatted data from a stream.">fscanf()</a>. <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="stdio_8h.html" title="C Standard I/O.">stdio.h</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="socket_8h.html" title="UDP and TCP socket interface definitions.">sys/socket.h</a>&gt;</span>

 ...

 TCPSOCKET *sock;
 <a class="code" href="group__xg_crt_stdio.html#gb940bd570245f248e9464829cd7c8c75" title="Stream structure type.">FILE</a> *stream;

 ...

 stream = <a class="code" href="group__xg_crt_stdio.html#g907a98011e3468d951740abecb768685" title="Open a stream associated with a file, device or socket descriptor.">_fdopen</a>((<span class="keywordtype">int</span>) sock, <span class="stringliteral">"r+b"</span>);
 <a class="code" href="group__xg_crt_stdio.html#g2f7351ee13f3f4c465c65e849a12a3fd" title="Print formatted data to a stream.">fprintf</a>(stream, <span class="stringliteral">"Hello peer\r\n"</span>);
</pre></div><p>
Remember, that Nut/OS streams are opened in text mode by default. Thus, we explicitly specify binary mode for the stream.<p>
The application programmer can modify some default values of the TCP stack by calling <a class="el" href="group__xg_tcp_socket.html#gb3bd1c81e2046e53cde6973b9c6bf6f4" title="Set value of a TCP socket option.">NutTcpSetSockOpt()</a>. This could be useful to fine tune the stack for maximum performance at minimum resource usage.<p>
In addition you may call <a class="el" href="group__xg_tcp_socket.html#gb3bd1c81e2046e53cde6973b9c6bf6f4" title="Set value of a TCP socket option.">NutTcpSetSockOpt()</a> to set a receive timeout in order to detect broken connections. That's often required, because TCP relies on a gracefully closed connection on the remote side. If the remote crashes or if the physical connection breaks, then <a class="el" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive()</a> will never return unless a receive timeout value had been set. At least this is true for Nut/Net, which currently doesn't support the <a class="el" href="socket_8h.html#0691781c519eed3f9a634f8eb55cd258" title="Keep connections alive.">SO_KEEPALIVE</a> option.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="socket_8h.html" title="UDP and TCP socket interface definitions.">sys/socket.h</a>&gt;</span>

 ...

 UDPSOCKET *sock;
 <a class="code" href="group__xg_nut_o_s.html#g8f25a50daf29ce2cee1ec038a4d744ea" title="Unsigned 32-bit value.">u_long</a> tmo = 3000;
 <span class="keywordtype">int</span> rc;
 <span class="keywordtype">char</span> buff[128];

 ...

 <a class="code" href="group__xg_tcp_socket.html#gb3bd1c81e2046e53cde6973b9c6bf6f4" title="Set value of a TCP socket option.">NutTcpSetSockOpt</a>(sock, <a class="code" href="socket_8h.html#f2d1ed6a34336a6f3df80fb518325846" title="Receive timeout.">SO_RCVTIMEO</a>, &amp;tmo, <span class="keyword">sizeof</span>(tmo));

 ...

 rc = <a class="code" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive</a>(sock, buff, <span class="keyword">sizeof</span>(buf));
 <span class="keywordflow">if</span> (rc == 0) {
     <span class="comment">/* </span>
<span class="comment">      * A timeout occured. We will now perform an application specific</span>
<span class="comment">      * action to check wether our remote is still alive.</span>
<span class="comment">      */</span>
 ...

 }
</pre></div><p>
Note again the difference to the Berkley API, where select() is used to determine receive timeouts.<p>
Most socket API calls return -1 in case of a failure. The function <a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError()</a> can be used to query a more specific error code. <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="stdio_8h.html" title="C Standard I/O.">stdio.h</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="socket_8h.html" title="UDP and TCP socket interface definitions.">sys/socket.h</a>&gt;</span>

 ...

 TCPSOCKET *sock;
 <a class="code" href="group__xg_nut_o_s.html#g8f25a50daf29ce2cee1ec038a4d744ea" title="Unsigned 32-bit value.">u_long</a> <a class="code" href="structip.html" title="Structure of an internet header.">ip</a> = <a class="code" href="group__xg_i_p.html#gdbce564458332a83ab871b91a54269dd" title="Convert decimal dotted ASCII representation into numeric IP address.">inet_addr</a>(<span class="stringliteral">"192.168.1.100"</span>);
 <a class="code" href="group__xg_nut_o_s.html#ga1a19deefc008737e6397f44d983cfd4" title="Unsigned 16-bit value.">u_short</a> port = 20191;
 <span class="keywordtype">int</span> tcperr;

 ...

 <span class="keywordflow">if</span> (<a class="code" href="group__xg_tcp_socket.html#g48ff1e877483a0833cf38e428eac6457" title="Connect to a remote socket.">NutTcpConnect</a>(sock, ip, port)) {
     tcperr = <a class="code" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError</a>(sock);
     <a class="code" href="icc_8h.html#3cb9f0894fab1c8fbb0753c9c7c2a8d9" title="Specify enhanced AVR target.">printf</a>(<span class="stringliteral">"TCP Error: "</span>);
     <span class="keywordflow">switch</span>(tcperr) {
     <span class="keywordflow">case</span> <a class="code" href="errno_8h.html#53e186028fc992c3341ccb0d4d239b24">EHOSTUNREACH</a>:
         <a class="code" href="icc_8h.html#3cb9f0894fab1c8fbb0753c9c7c2a8d9" title="Specify enhanced AVR target.">printf</a>(<span class="stringliteral">"No route to %s\n"</span>, <a class="code" href="group__xg_i_p.html#g9daa3cef32d6bcb76a95d0e869fd8b7a" title="Convert numeric IP address into decimal dotted ASCII representation.">inet_ntoa</a>(ip));
         <span class="keywordflow">break</span>;
     <span class="keywordflow">default</span>:
         <a class="code" href="icc_8h.html#3cb9f0894fab1c8fbb0753c9c7c2a8d9" title="Specify enhanced AVR target.">printf</a>(<span class="stringliteral">"%d\n"</span>, tcperr);
         <span class="keywordflow">break</span>;
     }
 }
</pre></div> <hr><h2>Define Documentation</h2>
<a class="anchor" name="gefdf0c5749674efdd40a37857ca45f78"></a><!-- doxytag: member="sock_var.h::SO_FIN" ref="gefdf0c5749674efdd40a37857ca45f78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_FIN&nbsp;&nbsp;&nbsp;0x01          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket transmit flag. Send FIN after all data has been transmitted. 
<p>

<p>Definition at line <a class="el" href="sock__var_8h-source.html#l00270">270</a> of file <a class="el" href="sock__var_8h-source.html">sock_var.h</a>.</p>

<p>Referenced by <a class="el" href="tcpout_8c-source.html#l00209">NutTcpOutput()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4a15c49046e1b3c0c3b4a3fad2b55c6c"></a><!-- doxytag: member="sock_var.h::SO_SYN" ref="g4a15c49046e1b3c0c3b4a3fad2b55c6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_SYN&nbsp;&nbsp;&nbsp;0x02          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket transmit flag. Send SYN first. 
<p>

<p>Definition at line <a class="el" href="sock__var_8h-source.html#l00271">271</a> of file <a class="el" href="sock__var_8h-source.html">sock_var.h</a>.</p>

<p>Referenced by <a class="el" href="tcpout_8c-source.html#l00209">NutTcpOutput()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g070f5c81fc9c6442a0576f42d67c794c"></a><!-- doxytag: member="sock_var.h::SO_FORCE" ref="g070f5c81fc9c6442a0576f42d67c794c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_FORCE&nbsp;&nbsp;&nbsp;0x08          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket transmit flag. Force sending ACK. 
<p>

<p>Definition at line <a class="el" href="sock__var_8h-source.html#l00272">272</a> of file <a class="el" href="sock__var_8h-source.html">sock_var.h</a>.</p>

<p>Referenced by <a class="el" href="tcpout_8c-source.html#l00209">NutTcpOutput()</a>, <a class="el" href="tcpsm_8c-source.html#l01643">NutTcpSm()</a>, and <a class="el" href="tcpsm_8c-source.html#l00918">NutTcpStateWindowEvent()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb60d40db730ce72950328301beae2c1c"></a><!-- doxytag: member="sock_var.h::SO_ACK" ref="gb60d40db730ce72950328301beae2c1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_ACK&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket transmit flag. Send ACK. 
<p>

<p>Definition at line <a class="el" href="sock__var_8h-source.html#l00273">273</a> of file <a class="el" href="sock__var_8h-source.html">sock_var.h</a>.</p>

<p>Referenced by <a class="el" href="tcpout_8c-source.html#l00209">NutTcpOutput()</a>, <a class="el" href="tcpsock_8c-source.html#l00694">NutTcpSend()</a>, <a class="el" href="tcpsm_8c-source.html#l01643">NutTcpSm()</a>, and <a class="el" href="tcpsm_8c-source.html#l00918">NutTcpStateWindowEvent()</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge062b546a18e3a15d4fa87209d6160ca"></a><!-- doxytag: member="tcpsock.c::NutTcpDiscardBuffers" ref="ge062b546a18e3a15d4fa87209d6160ca" args="(TCPSOCKET *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutTcpDiscardBuffers           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00244">244</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="netbuf_8c-source.html#l00299">NutNetBufFree()</a>.</p>

<p>Referenced by <a class="el" href="tcpsm_8c-source.html#l01803">NutTcpAbortSocket()</a>, and <a class="el" href="tcpsock_8c-source.html#l00273">NutTcpDestroySocket()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g551224f0a840a9cbf97b4d49dbc7c018"></a><!-- doxytag: member="tcpsock.c::NutTcpDestroySocket" ref="g551224f0a840a9cbf97b4d49dbc7c018" args="(TCPSOCKET *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutTcpDestroySocket           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a previously allocated socket. 
<p>
Remove socket from the socket list and release occupied memory.<p>
Applications must not call this function. It is automatically called by a timer after the socket has been closed by <a class="el" href="group__xg_tcp_socket.html#g09d94fd887683a0837e06c2cc08fc7ba" title="Close TCP socket.">NutTcpCloseSocket()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00273">273</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="icc_8h-source.html#l00145">free</a>, <a class="el" href="memset_8c-source.html#l00088">memset()</a>, <a class="el" href="tcpsock_8c-source.html#l00244">NutTcpDiscardBuffers()</a>, and <a class="el" href="tcpsock_8c-source.html#l00238">tcpSocketList</a>.</p>

<p>Referenced by <a class="el" href="tcpsm_8c-source.html#l01643">NutTcpSm()</a>, and <a class="el" href="tcpsm_8c-source.html#l00863">NutTcpStateCloseEvent()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g376cfd10344a38e74cde7ee2667ae3fe"></a><!-- doxytag: member="tcpsock.c::NutTcpFindSocket" ref="g376cfd10344a38e74cde7ee2667ae3fe" args="(uint16_t lport, uint16_t rport, uint32_t raddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCPSOCKET* NutTcpFindSocket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>lport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>rport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>raddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a matching socket. 
<p>
Loop through all sockets and find a matching connection (prefered) or a listening socket.<p>
Applications typically do not call this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lport</em>&nbsp;</td><td>Local port number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rport</em>&nbsp;</td><td>Remote port number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raddr</em>&nbsp;</td><td>Remote IP address in network byte order.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Socket descriptor. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00323">323</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="tcp__fsm_8h-source.html#l00095">TCPS_CLOSED</a>, <a class="el" href="tcp__fsm_8h-source.html#l00096">TCPS_LISTEN</a>, and <a class="el" href="tcpsock_8c-source.html#l00238">tcpSocketList</a>.</p>

<p>Referenced by <a class="el" href="tcpsm_8c-source.html#l01643">NutTcpSm()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6bf8ec59828c5a0e38423293b4dfe8e6"></a><!-- doxytag: member="tcpsock.c::NutTcpCreateSocket" ref="g6bf8ec59828c5a0e38423293b4dfe8e6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCPSOCKET* NutTcpCreateSocket           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a TCP socket. 
<p>
Allocates a TCPSOCKET structure from heap memory, initializes it and returns a pointer to that structure.<p>
The very first call will also start the TCP state machine, which is running in a separate thread.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Socket descriptor of the newly created TCP socket or 0 if there is not enough memory left.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>Avoid fixed initial sequence number. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00375">375</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="icc_8h-source.html#l00143">calloc</a>, <a class="el" href="device_8h-source.html#l00139">IFTYP_TCPSOCK</a>, <a class="el" href="in_8h-source.html#l00132">IPPROTO_TCP</a>, <a class="el" href="timer_8c-source.html#l00681">NutGetTickCount()</a>, <a class="el" href="ipdemux_8c-source.html#l00120">NutRegisterIpHandler()</a>, <a class="el" href="tcpsock_8c-source.html#l01144">NutTcpDeviceIOCtl()</a>, <a class="el" href="tcpsock_8c-source.html#l00938">NutTcpDeviceRead()</a>, <a class="el" href="tcpsock_8c-source.html#l00978">NutTcpDeviceWrite()</a>, <a class="el" href="tcpsock_8c-source.html#l01106">NutTcpDeviceWrite_P()</a>, <a class="el" href="tcpsm_8c-source.html#l01782">NutTcpInitStateMachine()</a>, <a class="el" href="tcpin_8c-source.html#l00148">NutTcpInput()</a>, <a class="el" href="netinet_2tcp_8h-source.html#l00192">TCP_MSS</a>, <a class="el" href="netinet_2tcp_8h-source.html#l00200">TCP_WINSIZE</a>, <a class="el" href="tcp__fsm_8h-source.html#l00095">TCPS_CLOSED</a>, and <a class="el" href="tcpsock_8c-source.html#l00238">tcpSocketList</a>.</p>

<p>Referenced by <a class="el" href="ftpserv_8c-source.html#l00274">FtpService()</a>, <a class="el" href="inetq_8c-source.html#l00126">main()</a>, <a class="el" href="ftpd_8c-source.html#l00447">NutFtpDataConnect()</a>, <a class="el" href="scanner_8c-source.html#l00263">Scanner()</a>, <a class="el" href="portdio_8c-source.html#l00397">service()</a>, and <a class="el" href="httpserv_8c-source.html#l00646">Service()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb3bd1c81e2046e53cde6973b9c6bf6f4"></a><!-- doxytag: member="tcpsock.c::NutTcpSetSockOpt" ref="gb3bd1c81e2046e53cde6973b9c6bf6f4" args="(TCPSOCKET *sock, int optname, CONST void *optval, int optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpSetSockOpt           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set value of a TCP socket option. 
<p>
The following values can be set:<p>
<ul>
<li><a class="el" href="netinet_2tcp_8h.html#f20c12fa9bf018281e14c3b43b777e2e" title="Set maximum segment size.">TCP_MAXSEG</a> Maximum segment size (<a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>). Can only be set if socket is not yet connected.</li><li><a class="el" href="socket_8h.html#b9d2f7ca5c94bd51cdab3e1913b66e2d" title="Send timeout.">SO_SNDTIMEO</a> Socket send timeout (<a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>).</li><li><a class="el" href="socket_8h.html#f2d1ed6a34336a6f3df80fb518325846" title="Receive timeout.">SO_RCVTIMEO</a> Socket receive timeout (<a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>).</li><li><a class="el" href="socket_8h.html#f618cbb85161ff3196d3bcdf7565ba64" title="Send buffer size.">SO_SNDBUF</a> Socket output buffer size (<a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>Option to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length of the value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError()</a>. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00435">435</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00075">EINVAL</a>, <a class="el" href="errno_8h-source.html#l00118">EISCONN</a>, <a class="el" href="socket_8h-source.html#l00163">SO_RCVBUF</a>, <a class="el" href="socket_8h-source.html#l00166">SO_SNDTIMEO</a>, <a class="el" href="netinet_2tcp_8h-source.html#l00218">TCP_MAXSEG</a>, and <a class="el" href="tcp__fsm_8h-source.html#l00095">TCPS_CLOSED</a>.</p>

<p>Referenced by <a class="el" href="ftpserv_8c-source.html#l00274">FtpService()</a>, <a class="el" href="ftpd_8c-source.html#l00447">NutFtpDataConnect()</a>, and <a class="el" href="scanner_8c-source.html#l00263">Scanner()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g357055ae6ebc31de5dd3e85ebd132108"></a><!-- doxytag: member="tcpsock.c::NutTcpGetSockOpt" ref="g357055ae6ebc31de5dd3e85ebd132108" args="(TCPSOCKET *sock, int optname, void *optval, int optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpGetSockOpt           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a TCP socket option value. 
<p>
The following values can be set:<p>
<ul>
<li><a class="el" href="netinet_2tcp_8h.html#f20c12fa9bf018281e14c3b43b777e2e" title="Set maximum segment size.">TCP_MAXSEG</a> Maximum segment size (<a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>).</li><li><a class="el" href="socket_8h.html#b9d2f7ca5c94bd51cdab3e1913b66e2d" title="Send timeout.">SO_SNDTIMEO</a> Socket send timeout (<a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>).</li><li><a class="el" href="socket_8h.html#f2d1ed6a34336a6f3df80fb518325846" title="Receive timeout.">SO_RCVTIMEO</a> Socket receive timeout (<a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>).</li><li><a class="el" href="socket_8h.html#f618cbb85161ff3196d3bcdf7565ba64" title="Send buffer size.">SO_SNDBUF</a> Socket output buffer size (<a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>Option to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Points to a buffer receiving the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length of the value buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError()</a>. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00518">518</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00075">EINVAL</a>, <a class="el" href="socket_8h-source.html#l00163">SO_RCVBUF</a>, <a class="el" href="socket_8h-source.html#l00166">SO_SNDTIMEO</a>, and <a class="el" href="netinet_2tcp_8h-source.html#l00218">TCP_MAXSEG</a>.</p>

</div>
</div><p>
<a class="anchor" name="g48ff1e877483a0833cf38e428eac6457"></a><!-- doxytag: member="tcpsock.c::NutTcpConnect" ref="g48ff1e877483a0833cf38e428eac6457" args="(TCPSOCKET *sock, uint32_t addr, uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpConnect           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to a remote socket. 
<p>
This function tries to establish a connection to the specified remote port of the specified remote server. The calling thread will be suspended until a connection is successfully established or an error occurs.<p>
This function is typically used by TCP client applications.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of the host to connect (network byte order). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port number to connect (host byte order).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError()</a>. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00595">595</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00130">EHOSTUNREACH</a>, <a class="el" href="errno_8h-source.html#l00118">EISCONN</a>, <a class="el" href="errno_8h-source.html#l00105">EOPNOTSUPP</a>, <a class="el" href="types_8h-source.html#l00321">htons</a>, <a class="el" href="route_8c-source.html#l00347">NutIpRouteQuery()</a>, <a class="el" href="tcpsm_8c-source.html#l00831">NutTcpStateActiveOpenEvent()</a>, <a class="el" href="tcp__fsm_8h-source.html#l00095">TCPS_CLOSED</a>, <a class="el" href="tcp__fsm_8h-source.html#l00096">TCPS_LISTEN</a>, and <a class="el" href="tcpsock_8c-source.html#l00238">tcpSocketList</a>.</p>

<p>Referenced by <a class="el" href="inetq_8c-source.html#l00126">main()</a>, <a class="el" href="ftpd_8c-source.html#l00447">NutFtpDataConnect()</a>, and <a class="el" href="scanner_8c-source.html#l00263">Scanner()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3859b3c38665aedc32608827f931498a"></a><!-- doxytag: member="tcpsock.c::NutTcpAccept" ref="g3859b3c38665aedc32608827f931498a" args="(TCPSOCKET *sock, uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpAccept           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for incoming connect from a remote socket. 
<p>
The calling thread will be suspended until until an incoming connection request is received.<p>
This function is typically used by TCP server applications.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port number to listen to (host byte order).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. The specific error code can be retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError()</a>. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00671">671</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="types_8h-source.html#l00321">htons</a>, and <a class="el" href="tcpsm_8c-source.html#l00806">NutTcpStatePassiveOpenEvent()</a>.</p>

<p>Referenced by <a class="el" href="ftpserv_8c-source.html#l00274">FtpService()</a>, <a class="el" href="pppc_8c-source.html#l00312">main()</a>, <a class="el" href="ftpd_8c-source.html#l00447">NutFtpDataConnect()</a>, <a class="el" href="portdio_8c-source.html#l00397">service()</a>, and <a class="el" href="httpserv_8c-source.html#l00646">Service()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfc14dd4c910afbb9269adc5bebba0281"></a><!-- doxytag: member="tcpsock.c::NutTcpSend" ref="gfc14dd4c910afbb9269adc5bebba0281" args="(TCPSOCKET *sock, CONST void *data, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpSend           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send data on a connected TCP socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. In addition a connection must have been established by calling NutTcpConnect or NutTcpAccept. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to a buffer containing the data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to be sent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If successful, the number of bytes added to the socket transmit buffer. This is limited to the maximum segment size of the connection and thus may be less than the specified number of bytes to send. The return value -1 indicates a fatal error. On time out, a value of 0 is returned. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00694">694</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00119">ENOTCONN</a>, <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="tcpout_8c-source.html#l00209">NutTcpOutput()</a>, <a class="el" href="os_2thread_8c-source.html#l00468">NutThreadYield()</a>, <a class="el" href="sock__var_8h-source.html#l00273">SO_ACK</a>, and <a class="el" href="tcp__fsm_8h-source.html#l00099">TCPS_ESTABLISHED</a>.</p>

<p>Referenced by <a class="el" href="inetq_8c-source.html#l00126">main()</a>, and <a class="el" href="ftpd_8c-source.html#l00705">NutFtpTransferFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb08d3e50fd09da18b966af0dd23fa4aa"></a><!-- doxytag: member="tcpsock.c::NutTcpReceive" ref="gb08d3e50fd09da18b966af0dd23fa4aa" args="(TCPSOCKET *sock, void *data, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpReceive           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive data on a connected TCP socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. In addition a connection must have been established by calling NutTcpConnect or NutTcpAccept. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to the buffer that receives the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If successful, the number of received data bytes is returned. This may be less than the specified size of the buffer. The return value 0 indicates a timeout, while -1 is returned in case of an error or broken connection. Call <a class="el" href="group__xg_tcp_socket.html#g3953f713369f008979d738b32d8fc255" title="Return specific code of the last error.">NutTcpError()</a> to determine the specific error code. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00764">764</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00119">ENOTCONN</a>, <a class="el" href="memcpy_8c-source.html#l00114">memcpy()</a>, <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="netbuf_8c-source.html#l00299">NutNetBufFree()</a>, <a class="el" href="tcpsm_8c-source.html#l00918">NutTcpStateWindowEvent()</a>, <a class="el" href="os_2thread_8c-source.html#l00468">NutThreadYield()</a>, <a class="el" href="tcp__fsm_8h-source.html#l00100">TCPS_CLOSE_WAIT</a>, and <a class="el" href="tcp__fsm_8h-source.html#l00099">TCPS_ESTABLISHED</a>.</p>

<p>Referenced by <a class="el" href="inetq_8c-source.html#l00126">main()</a>, <a class="el" href="ftpd_8c-source.html#l00705">NutFtpTransferFile()</a>, and <a class="el" href="tcpsock_8c-source.html#l00938">NutTcpDeviceRead()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g09d94fd887683a0837e06c2cc08fc7ba"></a><!-- doxytag: member="tcpsock.c::NutTcpCloseSocket" ref="g09d94fd887683a0837e06c2cc08fc7ba" args="(TCPSOCKET *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpCloseSocket           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close TCP socket. 
<p>
Note, that the socket may not be immediately destroyed after calling this function. However, the application must not use the socket after this call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00856">856</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="tcpsock_8c-source.html#l00978">NutTcpDeviceWrite()</a>, and <a class="el" href="tcpsm_8c-source.html#l00863">NutTcpStateCloseEvent()</a>.</p>

<p>Referenced by <a class="el" href="ftpserv_8c-source.html#l00274">FtpService()</a>, <a class="el" href="inetq_8c-source.html#l00126">main()</a>, <a class="el" href="ftpd_8c-source.html#l00447">NutFtpDataConnect()</a>, <a class="el" href="ftpd_8c-source.html#l00784">NutFtpTransferDirectory()</a>, <a class="el" href="ftpd_8c-source.html#l00705">NutFtpTransferFile()</a>, <a class="el" href="scanner_8c-source.html#l00263">Scanner()</a>, <a class="el" href="portdio_8c-source.html#l00397">service()</a>, and <a class="el" href="httpserv_8c-source.html#l00646">Service()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3953f713369f008979d738b32d8fc255"></a><!-- doxytag: member="tcpsock.c::NutTcpError" ref="g3953f713369f008979d738b32d8fc255" args="(TCPSOCKET *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpError           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return specific code of the last error. 
<p>
Possible error codes (<a class="el" href="net_2errno_8h.html" title="Network error definitions.">net/errno.h</a>) are:<p>
<ul>
<li>EWOULDBLOCK: Operation would block</li><li>EINPROGRESS: Operation now in progress</li><li>EALREADY: Operation already in progress</li><li>ENOTSOCK: Socket operation on non-socket</li><li>EDESTADDRREQ: Destination address required</li><li>EMSGSIZE: Message too long</li><li>EPROTOTYPE: Protocol wrong type for socket</li><li>ENOPROTOOPT: Protocol not available</li><li>EPROTONOSUPPORT: Protocol not supported</li><li>ESOCKTNOSUPPORT: Socket type not supported</li><li>EOPNOTSUPP: Operation not supported on socket</li><li>EPFNOSUPPORT: Protocol family not supported</li><li>EAFNOSUPPORT: Address family not supported by protocol family</li><li>EADDRINUSE: Address already in use</li><li>EADDRNOTAVAIL: Can't assign requested address</li><li>ENETDOWN: Network is down</li><li>ENETUNREACH: Network is unreachable</li><li>ENETRESET: Network dropped connection on reset</li><li>ECONNABORTED: Software caused connection abort</li><li>ECONNRESET: Connection reset by peer</li><li>ENOBUFS: No buffer space available</li><li>EISCONN: Socket is already connected</li><li>ENOTCONN: Socket is not connected</li><li>ESHUTDOWN: Can't send after socket shutdown</li><li>ETOOMANYREFS: Too many references: can't splice</li><li>ETIMEDOUT: Connection timed out</li><li>ECONNREFUSED: Connection refused</li><li>ELOOP: Too many levels of symbolic links</li><li>ENAMETOOLONG: File name too long</li><li>EHOSTDOWN: Host is down</li><li>EHOSTUNREACH: No route to host</li><li>ENOTEMPTY: Directory not empty</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Applications must not call this function to retrieve the error code if <a class="el" href="group__xg_tcp_socket.html#g09d94fd887683a0837e06c2cc08fc7ba" title="Close TCP socket.">NutTcpCloseSocket()</a> or <a class="el" href="group__xg_tcp_socket.html#g551224f0a840a9cbf97b4d49dbc7c018" title="Destroy a previously allocated socket.">NutTcpDestroySocket()</a> failed.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>Not all error codes are properly set right now. Some socket functions return an error without setting an error code. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00912">912</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00098">ENOTSOCK</a>.</p>

<p>Referenced by <a class="el" href="scanner_8c-source.html#l00263">Scanner()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc4ab675d039b53314b37b12b70afefd5"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceRead" ref="gc4ab675d039b53314b37b12b70afefd5" args="(TCPSOCKET *sock, void *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpDeviceRead           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read from virtual socket device. 
<p>
TCP sockets can be used like other Nut/OS devices. This routine is part of the virtual socket device driver.<p>
This function is called by the low level input routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#0b784cc08be2375571b449ebcb2663db" title="Read from device.">_NUTDEVICE::dev_read</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the buffer that receives the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Maximum number of bytes to read.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read, which may be less than the number of bytes specified. A return value of -1 indicates an error, while zero is returned in case of a timeout. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00938">938</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="tcpsock_8c-source.html#l00764">NutTcpReceive()</a>.</p>

<p>Referenced by <a class="el" href="tcpsock_8c-source.html#l00375">NutTcpCreateSocket()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9e0cdc2012de837e6b81006b9b32ca12"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceWrite" ref="g9e0cdc2012de837e6b81006b9b32ca12" args="(TCPSOCKET *sock, CONST void *buf, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpDeviceWrite           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to a socket. 
<p>
TCP sockets can be used like other Nut/OS devices. This routine is part of the virtual socket device driver.<p>
This function is called by the low level output routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#f4d266bf15c47743230962d9b960d24c">_NUTDEVICE::dev_write</a> entry.<p>
In contrast to <a class="el" href="group__xg_tcp_socket.html#gfc14dd4c910afbb9269adc5bebba0281" title="Send data on a connected TCP socket.">NutTcpSend()</a> this routine provides some buffering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the data to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of bytes to write. If zero, then the output buffer will be flushed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written. A return value of -1 indicates an error. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00978">978</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="errno_8h-source.html#l00119">ENOTCONN</a>, <a class="el" href="icc_8h-source.html#l00145">free</a>, <a class="el" href="icc_8h-source.html#l00142">malloc</a>, <a class="el" href="memcpy_8c-source.html#l00114">memcpy()</a>, and <a class="el" href="tcp__fsm_8h-source.html#l00099">TCPS_ESTABLISHED</a>.</p>

<p>Referenced by <a class="el" href="tcpsock_8c-source.html#l00856">NutTcpCloseSocket()</a>, <a class="el" href="tcpsock_8c-source.html#l00375">NutTcpCreateSocket()</a>, and <a class="el" href="tcpsock_8c-source.html#l01106">NutTcpDeviceWrite_P()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g71f2a257f72723170c19ad7b5d9f991f"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceWrite_P" ref="g71f2a257f72723170c19ad7b5d9f991f" args="(TCPSOCKET *sock, PGM_P buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpDeviceWrite_P           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to device. 
<p>
This function is implemented for CPUs with Harvard Architecture only.<p>
TCP sockets can be used like other Nut/OS devices. This routine is part of the virtual socket device driver and similar to <a class="el" href="group__xg_tcp_socket.html#g9e0cdc2012de837e6b81006b9b32ca12" title="Write to a socket.">NutTcpDeviceWrite()</a> except that the data is located in program memory.<p>
This function is called by the low level output routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#d8372c14180f06a336eafc0eb7683c8a">_NUTDEVICE::dev_write_P</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the data in program space to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of bytes to write.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Inefficient implementation. No buffering has been implemented. Thus, each call will result in a separate TCP segment. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l01106">1106</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="arm_8h-source.html#l00171">memcpy_P</a>, <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, and <a class="el" href="tcpsock_8c-source.html#l00978">NutTcpDeviceWrite()</a>.</p>

<p>Referenced by <a class="el" href="tcpsock_8c-source.html#l00375">NutTcpCreateSocket()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gceb6b4b842cb85f48f6ca163c7aa1ce0"></a><!-- doxytag: member="tcpsock.c::NutTcpDeviceIOCtl" ref="gceb6b4b842cb85f48f6ca163c7aa1ce0" args="(TCPSOCKET *sock, int cmd, void *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutTcpDeviceIOCtl           </td>
          <td>(</td>
          <td class="paramtype">TCPSOCKET *&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Driver control function. 
<p>
Used by the virtual device driver to modify or query device specific settings.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Socket descriptor. This pointer must have been retrieved by calling <a class="el" href="group__xg_tcp_socket.html#g6bf8ec59828c5a0e38423293b4dfe8e6" title="Create a TCP socket.">NutTcpCreateSocket()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>Requested control function. May be set to one of the following constants:<ul>
<li><a class="el" href="group__xg_crt_lowio.html#gb36ad110d70105bd33c1e0c9be137339">IOCTL_GETFILESIZE</a></li><li><a class="el" href="group__xg_crt_lowio.html#ge06e732c285bea82878b1b82377b437d">IOCTL_GETINBUFCOUNT</a></li><li><a class="el" href="group__xg_crt_lowio.html#g809cc6bff637bb28aad35eeaaeed26bb">IOCTL_GETOUTBUFCOUNT</a></li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>Points to a buffer that contains any data required for the given control function or receives data from that function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l01144">1144</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>References <a class="el" href="io_8h-source.html#l00080">IOCTL_GETFILESIZE</a>, <a class="el" href="io_8h-source.html#l00086">IOCTL_GETINBUFCOUNT</a>, and <a class="el" href="io_8h-source.html#l00083">IOCTL_GETOUTBUFCOUNT</a>.</p>

<p>Referenced by <a class="el" href="tcpsock_8c-source.html#l00375">NutTcpCreateSocket()</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g2fcec3521061173b7bdd704877a57395"></a><!-- doxytag: member="tcpsock.c::tcpSocketList" ref="g2fcec3521061173b7bdd704877a57395" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCPSOCKET* <a class="el" href="group__xg_tcp_socket.html#g2fcec3521061173b7bdd704877a57395">tcpSocketList</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global linked list of all TCP sockets. 
<p>Definition at line <a class="el" href="tcpsock_8c-source.html#l00238">238</a> of file <a class="el" href="tcpsock_8c-source.html">tcpsock.c</a>.</p>

<p>Referenced by <a class="el" href="netdebug_8c-source.html#l00173">NutDumpSocketList()</a>, <a class="el" href="tcpsock_8c-source.html#l00595">NutTcpConnect()</a>, <a class="el" href="tcpsock_8c-source.html#l00375">NutTcpCreateSocket()</a>, <a class="el" href="tcpsock_8c-source.html#l00273">NutTcpDestroySocket()</a>, <a class="el" href="tcpsock_8c-source.html#l00323">NutTcpFindSocket()</a>, and <a class="el" href="tcpsm_8c-source.html#l01643">NutTcpSm()</a>.</p>

</div>
</div><p>
</div>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2007 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
