<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
    <link href="nut_entabs.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Banked Memory<br>
<small>
[<a class="el" href="group__xg_app_sugar.html">Application Candies</a>]</small>
</h1>Banked RAM support.  
<a href="#_details">More...</a>
<p>

<p>
<div class="dynheader">
Collaboration diagram for Banked Memory:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__xg_bank_mem.png" border="0" alt="" usemap="#group____xg__bank__mem_map">
<map name="group____xg__bank__mem_map">
<area shape="rect" href="group__xg_app_sugar.html" title="In order to keep the kernel clean and small, it uses very basic functions only:." alt="Application Candies" coords="19,5,144,26"></map></td></tr></table></center>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#g59e6535d66539f29aed5909eb0b70eed">NutSegBufReset</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the segmented buffer.  <a href="#g59e6535d66539f29aed5909eb0b70eed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#g54b4fc4de72531a2c413219187019e71">NutSegBufInit</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the segmented buffer.  <a href="#g54b4fc4de72531a2c413219187019e71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#g5dca6c51548e7ee90dc79cddaa1668fd">NutSegBufWriteRequest</a> (size_t *bcp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request segmented buffer space for writing.  <a href="#g5dca6c51548e7ee90dc79cddaa1668fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gc9fb2d54037da348dfc6a9c99b47e75f">NutSegBufReadRequest</a> (size_t *bcp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request segmented buffer space for reading.  <a href="#gc9fb2d54037da348dfc6a9c99b47e75f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#ge7d02ba9e852fc6bde683efb8da33769">NutSegBufWriteCommit</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit written buffer space.  <a href="#ge7d02ba9e852fc6bde683efb8da33769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#g285f080acdb4ed3074e24387c179f76b">NutSegBufReadCommit</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit read buffer space.  <a href="#g285f080acdb4ed3074e24387c179f76b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#g435c70799400cd3fab9b305d9e83987c">NutSegBufWriteLast</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit written buffer space and finish write access.  <a href="#g435c70799400cd3fab9b305d9e83987c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gd9e27e0283495409f46e25e794286b4b">NutSegBufReadLast</a> (size_t bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit written buffer space and finish read access.  <a href="#gd9e27e0283495409f46e25e794286b4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#g866d595bca99894fdee0e1e59cdc5d7d">NutSegBufAvailable</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the available buffer space.  <a href="#g866d595bca99894fdee0e1e59cdc5d7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_bank_mem.html#gcc5a7121fca5d27017c4d9f851a90475">NutSegBufUsed</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the used buffer space.  <a href="#gcc5a7121fca5d27017c4d9f851a90475"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Banked RAM support. 
<p>
Even with a hardware decoder like the one used on the Medianut Board, streaming MP3 data in realtime from a TCP/IP network to the decoder requires some special techniques to make it work on a tiny 8 bit system.<p>
The key to success is avoidance of data copying. Usually data streams are moved from the Ethernet Controller to the Ethernet's driver buffer, then moved to the TCP buffer, again moved to the application buffer and finally from the application buffer to the MP3 decoder buffer. Some systems may use additional steps. Nut/OS tries to avoid these copies. In extreme, the data may be moved directly from the Ethernet controller to the MP3 controller. In reality this will fail, because TCP isn't realtime, but playing MP3 is. So at least one buffer stage is required to compensate the non deterministic arrival of TCP data. Each packet received is moved from the Ethernet controller into a so called NETBUF. Each NETBUF is added to a connection specific queue until the application request data from the connection. For portability reasons and to keep things simple, the application provides a buffer and calls <a class="el" href="group__xg_tcp_socket.html#gb08d3e50fd09da18b966af0dd23fa4aa" title="Receive data on a connected TCP socket.">NutTcpReceive()</a> to get that buffer filled with application data out of the queued NETBUFs. This is another copy, but frees the application from dealing with system specific NETBUF structures.<p>
The smart part is, that Nut/OS offers a special buffer management to avoid the final copy into the decoder buffer and that the Nut/OS MP3 decoder driver makes use of this buffer management. As stated, normally the application buffer is filled by some kind of read statement (first copy) and transfered to the driver by some kind of write statement (second copy).<p>
When using the segmented memory management, the application will query the driver for buffer space first and then pass this buffer to the TCP read routine. This way the TCP read routine will directly fill the buffer of the decoder driver. When this has been done, the application commits the buffer filled and requests a new one and so on.<p>
Finally the segmented memory mamagement API can not only handle a continuos memory space, but also one that is divided into several segments. This is usefull with banked memory hardware provided by Ethernut 2 boards.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>At least some parts should be moved to the device section. </dd></dl>
<p>
$Log$ Revision 1.7 2009/02/06 15:40:29 haraldkipp Using newly available <a class="el" href="group__xg_crt_string.html#g608db5821b635f6a719ecb7f76d4a5da" title="Create a copy of a string.">strdup()</a> and <a class="el" href="icc_8h.html#84beef8cc122add35118ec7cd35286c4">calloc()</a>. Replaced NutHeap routines by standard malloc/free. Replaced pointer value 0 by NULL.<p>
Revision 1.6 2008/08/11 07:00:33 haraldkipp BSD types replaced by stdint types (feature request #1282721).<p>
Revision 1.5 2008/02/15 17:08:05 haraldkipp Calling the initialization routine more than once is now possible. By default, half of the available memory will be allocated. Previous versions eat all free memory but 8k.<p>
Revision 1.4 2007/04/12 09:08:57 haraldkipp Segmented buffer routines ported to ARM.<p>
Revision 1.3 2004/12/17 15:28:33 haraldkipp Bugfix. Comparison of the read and write pointers now includes the segments. Thanks to Pete Allinson and Johan van der Stoel.<p>
Revision 1.2 2004/08/18 18:51:56 haraldkipp Made banked memory configurable.<p>
Revision 1.1 2003/07/21 18:19:48 haraldkipp First check in <hr><h2>Function Documentation</h2>
<a class="anchor" name="g59e6535d66539f29aed5909eb0b70eed"></a><!-- doxytag: member="bankmem.c::NutSegBufReset" ref="g59e6535d66539f29aed5909eb0b70eed" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufReset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the segmented buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the first buffer segment. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00094">94</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>, <a class="el" href="bankmem_8c-source.html#l00117">NutSegBufInit()</a>, and <a class="el" href="spi__vscodec_8c-source.html#l00620">VsCodecOpen()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g54b4fc4de72531a2c413219187019e71"></a><!-- doxytag: member="bankmem.c::NutSegBufInit" ref="g54b4fc4de72531a2c413219187019e71" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufInit           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the segmented buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of bytes to allocate for the global buffer. In systems with banked memory this parameter is ignored and all banked memory is occupied for the global buffer. In systems without banked memory, the specified number of bytes is taken from heap memory.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the first buffer segment or null on failures. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00117">117</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h-source.html#l00106">NUTBANK_COUNT</a>, <a class="el" href="memory_8h-source.html#l00124">NUTBANK_SIZE</a>, <a class="el" href="memory_8h-source.html#l00115">NUTBANK_START</a>, <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, <a class="el" href="heap_8h-source.html#l00076">NutHeapAvailable</a>, <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, and <a class="el" href="bankmem_8c-source.html#l00094">NutSegBufReset()</a>.</p>

<p>Referenced by <a class="el" href="nutpiper_8c-source.html#l00400">main()</a>, and <a class="el" href="spi__vscodec_8c-source.html#l00261">VsDecoderBufferInit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5dca6c51548e7ee90dc79cddaa1668fd"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteRequest" ref="g5dca6c51548e7ee90dc79cddaa1668fd" args="(size_t *bcp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufWriteRequest           </td>
          <td>(</td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bcp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request segmented buffer space for writing. 
<p>
This call will also enable the current write segment and may disable the current read segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bcp</em>&nbsp;</td><td>Pointer to a variable, which receives the number of consecutive bytes available for writing.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the next write position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00150">150</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c-source.html#l00552">VsCodecWrite()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc9fb2d54037da348dfc6a9c99b47e75f"></a><!-- doxytag: member="bankmem.c::NutSegBufReadRequest" ref="gc9fb2d54037da348dfc6a9c99b47e75f" args="(size_t *bcp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufReadRequest           </td>
          <td>(</td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bcp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request segmented buffer space for reading. 
<p>
This call will also enable the current read segment and may disable the current write segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bcp</em>&nbsp;</td><td>Pointer to a variable, which receives the number of consecutive bytes available for reading.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the next read position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00173">173</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge7d02ba9e852fc6bde683efb8da33769"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteCommit" ref="ge7d02ba9e852fc6bde683efb8da33769" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufWriteCommit           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit written buffer space. 
<p>
The write pointer will be incremented by the specified number of bytes. If the pointer reaches the end of a segment, the next segment will be enabled and the pointer will point to the start of the new segement.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the next write position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00197">197</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h-source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

</div>
</div><p>
<a class="anchor" name="g285f080acdb4ed3074e24387c179f76b"></a><!-- doxytag: member="bankmem.c::NutSegBufReadCommit" ref="g285f080acdb4ed3074e24387c179f76b" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NutSegBufReadCommit           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit read buffer space. 
<p>
The read pointer will be incremented by the specified number of bytes. If the pointer reaches the end of a segment, the next segment will be enabled and the pointer will point to the start of the new segement.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the next read position. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00226">226</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h-source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

</div>
</div><p>
<a class="anchor" name="g435c70799400cd3fab9b305d9e83987c"></a><!-- doxytag: member="bankmem.c::NutSegBufWriteLast" ref="g435c70799400cd3fab9b305d9e83987c" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutSegBufWriteLast           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit written buffer space and finish write access. 
<p>
The write pointer will be incremented by the specified number of bytes. This call will also enable the current read segment and may disable the current write segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00255">255</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h-source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c-source.html#l00552">VsCodecWrite()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd9e27e0283495409f46e25e794286b4b"></a><!-- doxytag: member="bankmem.c::NutSegBufReadLast" ref="gd9e27e0283495409f46e25e794286b4b" args="(size_t bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutSegBufReadLast           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit written buffer space and finish read access. 
<p>
The write pointer will be incremented by the specified number of bytes. This call will also enable the current read segment and may disable the current write segment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bc</em>&nbsp;</td><td>Number of bytes to commit. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00281">281</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>References <a class="el" href="memory_8h-source.html#l00106">NUTBANK_COUNT</a>, and <a class="el" href="sys_2bankmem_8h-source.html#l00103">NutSegBufEnable</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g866d595bca99894fdee0e1e59cdc5d7d"></a><!-- doxytag: member="bankmem.c::NutSegBufAvailable" ref="g866d595bca99894fdee0e1e59cdc5d7d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> NutSegBufAvailable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the available buffer space. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Total number of free bytes in the buffer. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00305">305</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>Referenced by <a class="el" href="spi__vscodec_8c-source.html#l00395">VsCodecIOCtl()</a>, and <a class="el" href="spi__vscodec_8c-source.html#l00261">VsDecoderBufferInit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcc5a7121fca5d27017c4d9f851a90475"></a><!-- doxytag: member="bankmem.c::NutSegBufUsed" ref="gcc5a7121fca5d27017c4d9f851a90475" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> NutSegBufUsed           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the used buffer space. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Total number of used bytes in the buffer. </dd></dl>

<p>Definition at line <a class="el" href="bankmem_8c-source.html#l00315">315</a> of file <a class="el" href="bankmem_8c-source.html">bankmem.c</a>.</p>

<p>Referenced by <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>, <a class="el" href="spi__vscodec_8c-source.html#l00395">VsCodecIOCtl()</a>, and <a class="el" href="vs1001k_8c-source.html#l00760">VsPlayerFlush()</a>.</p>

</div>
</div><p>
</div>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2007 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
