<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
    <link href="nut_entabs.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="dir_264e76a43993b4d38befcb6805fdec2d.html">arch</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_5b20284563abb99fd48bba427a81ed0c.html">unix</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_27a5e0e6bdfed06eca005589655e5d46.html">os</a>
  </div>
<div class="contents">
<h1>nutinit.c</h1><a href="arch_2unix_2os_2nutinit_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (C) 2000-2004 by ETH Zurich</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00006"></a>00006 <span class="comment"> * are met:</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00009"></a>00009 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00011"></a>00011 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00012"></a>00012 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<a name="l00013"></a>00013 <span class="comment"> * 3. Neither the name of the copyright holders nor the names of</span>
<a name="l00014"></a>00014 <span class="comment"> *    contributors may be used to endorse or promote products derived</span>
<a name="l00015"></a>00015 <span class="comment"> *    from this software without specific prior written permission.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY ETH ZURICH AND CONTRIBUTORS</span>
<a name="l00018"></a>00018 <span class="comment"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00019"></a>00019 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<a name="l00020"></a>00020 <span class="comment"> * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ETH ZURICH</span>
<a name="l00021"></a>00021 <span class="comment"> *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00022"></a>00022 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<a name="l00023"></a>00023 <span class="comment"> * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</span>
<a name="l00024"></a>00024 <span class="comment"> * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</span>
<a name="l00025"></a>00025 <span class="comment"> * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a name="l00026"></a>00026 <span class="comment"> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF</span>
<a name="l00027"></a>00027 <span class="comment"> * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<a name="l00028"></a>00028 <span class="comment"> * SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * For additional information see http://www.ethernut.de/</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> */</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">/* </span>
<a name="l00035"></a>00035 <span class="comment"> * unix_nutinit.c - init for unix emulation</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> * 2004.04.01 Matthias Ringwald &lt;matthias.ringwald@inf.ethz.ch&gt;</span>
<a name="l00038"></a>00038 <span class="comment"> *</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#ifdef __CYGWIN__</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/features.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html" title="C Standard I/O.">stdio.h</a>&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;<a class="code" href="unistd_8h.html" title="Miscellaneous function declarations.">unistd.h</a>&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;getopt.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;termios.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;<a class="code" href="os_8h.html">cfg/os.h</a>&gt;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;<a class="code" href="types_8h.html" title="Nut/OS type declarations.">sys/types.h</a>&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;<a class="code" href="event_8h.html" title="Event management definitions.">sys/event.h</a>&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;<a class="code" href="device_8h.html" title="Nut/OS device definitions.">sys/device.h</a>&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;<a class="code" href="osdebug_8h.html">sys/osdebug.h</a>&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;<a class="code" href="include_2sys_2atom_8h.html">sys/atom.h</a>&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;<a class="code" href="dev_2irqreg_8h.html" title="Interrupt management definitions.">dev/irqreg.h</a>&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;<a class="code" href="unix__devs_8h.html">dev/unix_devs.h</a>&gt;</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__xg_nut_arch_avr_init.html#gc03aa223c3c963c66026efcfbd8503d7">NutAppMain</a>(<span class="keywordtype">void</span> *arg) <a class="code" href="icc_8h.html#9d373a9b65ff25b2db84c07394e1c212" title="Object attribute support.">__attribute__</a> ((noreturn));
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#ifndef NUT_THREAD_MAINSTACK</span>
<a name="l00065"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#3e4d60795d76e168a6756f9b12c53431">00065</a> <span class="preprocessor"></span><span class="preprocessor">#define NUT_THREAD_MAINSTACK    1024</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 <span class="preprocessor">#ifndef NUT_THREAD_IDLESTACK</span>
<a name="l00069"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#e8b04c1eee99e2b3501a0361d397bd20">00069</a> <span class="preprocessor"></span><span class="preprocessor">#define NUT_THREAD_IDLESTACK    1024</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="comment">/* number of interrupts that can be outstanding before one is lost */</span>
<a name="l00073"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#158a7fd99e424e9710b04659a6e9ea6b">00073</a> <span class="preprocessor">#define MAX_IRQ_SLOTS 3</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="comment">/* type of raised interrupt (timer, usart, ...) */</span>
<a name="l00076"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#9eb9e75decd91fa21352eaf201b3b0c6">00076</a> <span class="keywordtype">int</span> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#9eb9e75decd91fa21352eaf201b3b0c6">interrupts_pending</a>[<a class="code" href="arch_2unix_2os_2nutinit_8c.html#158a7fd99e424e9710b04659a6e9ea6b">MAX_IRQ_SLOTS</a>];
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">/* our IRQ signal */</span>
<a name="l00079"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#7c4baba7be9ead5025b37220b7e07a54">00079</a> sigset_t <a class="code" href="include_2arch_2unix_2atom_8h.html#7c4baba7be9ead5025b37220b7e07a54">irq_signal</a>;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/* our emulated interrupt enabled/disabled flag */</span>
<a name="l00082"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#c2cbabed5de9b312e773560a120e5ca0">00082</a> <a class="code" href="stdint_8h.html#1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> <a class="code" href="include_2arch_2unix_2atom_8h.html#c2cbabed5de9b312e773560a120e5ca0">int_disabled</a>;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">/* index to first, next free, and first unsignalled interrupt type */</span>
<a name="l00085"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#2182f2313421619a8e6faf75037d5074">00085</a> <span class="keywordtype">int</span> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#2182f2313421619a8e6faf75037d5074">irq_current</a> = 0;
<a name="l00086"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#ef790d09d103378c323591173fe76e35">00086</a> <span class="keywordtype">int</span> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#ef790d09d103378c323591173fe76e35">irq_slot</a> = 0;
<a name="l00087"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#73d489ca62fc997c4f092feb5ca7a8a2">00087</a> <span class="keywordtype">int</span> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#73d489ca62fc997c4f092feb5ca7a8a2">irq_sent</a> = 0;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">/* interrupt thread, signalling Nut threads */</span>
<a name="l00090"></a>00090 <span class="keyword">static</span> pthread_t interrupt_thread;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/* mutex and condition variable used to signal that a new interrupt is pending */</span>
<a name="l00093"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#f5e31b637cf5379b0cb671f4971bc912">00093</a> pthread_mutex_t <a class="code" href="arch_2unix_2os_2nutinit_8c.html#f5e31b637cf5379b0cb671f4971bc912">pending_mutex</a>;
<a name="l00094"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#9d3086897d173beace07371b404b10e0">00094</a> pthread_cond_t <a class="code" href="arch_2unix_2os_2nutinit_8c.html#9d3086897d173beace07371b404b10e0">pending_cv</a>;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="comment">/* mutex and condition variable used to signal that interrupts have been re-enabled */</span>
<a name="l00097"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#b015a84df8c6b88241e830a9ad190726">00097</a> pthread_mutex_t <a class="code" href="arch_2unix_2os_2nutinit_8c.html#b015a84df8c6b88241e830a9ad190726">irq_mutex</a>;
<a name="l00098"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#8ac1dcf8584e3f38210aa5ac783f0585">00098</a> pthread_cond_t <a class="code" href="include_2arch_2unix_2atom_8h.html#8ac1dcf8584e3f38210aa5ac783f0585">irq_cv</a>;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">/* interrupt handler routines */</span>
<a name="l00101"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#2d319190081899fe29ecf9ca5b1aad3b">00101</a> <a class="code" href="struct_i_r_q___h_a_n_d_l_e_r.html">IRQ_HANDLER</a> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#2d319190081899fe29ecf9ca5b1aad3b">irq_handlers</a>[<a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>];
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="comment">/* event queues to signal from non-Nut thread */</span>
<a name="l00104"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#d6a2d005f960a87eb02f869cd0338313">00104</a> <a class="code" href="nut__types_8h.html#a8c0374618b33785ccb02f74bcfebc46" title="Void pointer.">HANDLE</a> *<a class="code" href="arch_2unix_2os_2nutinit_8c.html#d6a2d005f960a87eb02f869cd0338313">irq_eventqueues</a>[<a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>];
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 
<a name="l00119"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#d702875f3cb8d6ef76c22b616bb1b628">00119</a> <span class="keywordtype">int</span> <a class="code" href="group__xg_interrupt.html#ga459696030a9cdf621ce3df7b3ac939d" title="Register an interrupt handler.">NutRegisterIrqHandler</a>(<a class="code" href="stdint_8h.html#ba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> irq, <span class="keywordtype">void</span> (*handler) (<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg)
<a name="l00120"></a>00120 {
<a name="l00121"></a>00121     <span class="keywordflow">if</span> (irq &gt;= <a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>)
<a name="l00122"></a>00122         <span class="keywordflow">return</span> -1;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <a class="code" href="include_2arch_2arm_2atom_8h.html#87280d882ea631ee08df697179c5d9ad">NutEnterCritical</a>();
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     irq_handlers[irq].<a class="code" href="struct_i_r_q___h_a_n_d_l_e_r.html#a4dfa5d8b019d8d4a70111cd83b666f6">ir_arg</a> = arg;
<a name="l00127"></a>00127     irq_handlers[irq].<a class="code" href="struct_i_r_q___h_a_n_d_l_e_r.html#8d8231c9e42160b6439b2f10b2e307f6">ir_handler</a> = handler;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <a class="code" href="include_2arch_2arm_2atom_8h.html#06e861b2acb2eb533dd1928acdd868d9">NutExitCritical</a>();
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordflow">return</span> 0;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 
<a name="l00147"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#99298212a64142ea9d3e71cf9a9b44fe">00147</a> <span class="keywordtype">void</span> <a class="code" href="arch_2unix_2irqreg_8h.html#b9e5058db0590e5f86ad3dde13b83b34" title="Register NutEventPostAsync for next NutThreadYield.">NutUnixIrqEventPostAsync</a>(<a class="code" href="stdint_8h.html#ba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> irq, <a class="code" href="nut__types_8h.html#a8c0374618b33785ccb02f74bcfebc46" title="Void pointer.">HANDLE</a> * queue)
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149     <span class="keywordflow">if</span> (irq &lt; <a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>)
<a name="l00150"></a>00150         irq_eventqueues[irq] = queue;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00161"></a>00161 <span class="keywordtype">void</span> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#9a30bd9f48ccc047fd4557d18082990e" title="Handle interrupt triggered NutEventPostAsync Check list of events to post and call...">NutUnixThreadYieldHook</a>(<span class="keywordtype">void</span>);
<a name="l00162"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#9a30bd9f48ccc047fd4557d18082990e">00162</a> <span class="keywordtype">void</span> <a class="code" href="arch_2unix_2os_2nutinit_8c.html#9a30bd9f48ccc047fd4557d18082990e" title="Handle interrupt triggered NutEventPostAsync Check list of events to post and call...">NutUnixThreadYieldHook</a>()
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164     <a class="code" href="stdint_8h.html#ba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> irq;
<a name="l00165"></a>00165     <span class="keywordflow">for</span> (irq = 0; irq &lt; <a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>; irq++) {
<a name="l00166"></a>00166         <span class="keywordflow">if</span> (irq_eventqueues[irq] != 0) {
<a name="l00167"></a>00167             <span class="comment">// printf("NutUnixThreadYield posting event nr %d\n\r", irq);</span>
<a name="l00168"></a>00168             <a class="code" href="group__xg_event.html#gc52b53066d7486072b4e1ace5b4c6f3b" title="Post an event to a specified queue from interrupt context.">NutEventPostFromIrq</a>(irq_eventqueues[irq]);
<a name="l00169"></a>00169             irq_eventqueues[irq] = 0;
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">/*</span>
<a name="l00176"></a>00176 <span class="comment"> * Handles SIGINT</span>
<a name="l00177"></a>00177 <span class="comment"> *</span>
<a name="l00178"></a>00178 <span class="comment"> */</span>
<a name="l00179"></a>00179 <span class="keyword">static</span> <span class="keywordtype">void</span> NutUnixControlC(<span class="keywordtype">int</span>);
<a name="l00180"></a>00180 <span class="keyword">static</span> <span class="keywordtype">void</span> NutUnixControlC(<span class="keywordtype">int</span> signal)
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182     <a class="code" href="icc_8h.html#3cb9f0894fab1c8fbb0753c9c7c2a8d9" title="Specify enhanced AVR target.">printf</a>(<span class="stringliteral">"CTRL-C! Abort application.\n\r"</span>);
<a name="l00183"></a>00183     tcsetattr(fileno(<a class="code" href="group__xg_crt_stdio.html#g0c0ef221f95f64e8632451312fd18cc8" title="Standard output stream.">stdout</a>), TCSANOW, &amp;<a class="code" href="unix_8h.html#d0d96d193a75cdbe5630643d12c49503">emulation_options</a>.<a class="code" href="structemulation__options__t.html#a46a37a952cd24d84649ae775eeac175">saved_termios</a>);
<a name="l00184"></a>00184     exit(0);
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">/*</span>
<a name="l00188"></a>00188 <span class="comment"> * Signal handler for SIGUSR1</span>
<a name="l00189"></a>00189 <span class="comment"> * emulates interrupt hardware</span>
<a name="l00190"></a>00190 <span class="comment"> * serializes all interrupts and calls their corresponding handlers</span>
<a name="l00191"></a>00191 <span class="comment"> * </span>
<a name="l00192"></a>00192 <span class="comment"> * all IRQs are multiplexed through the same signal handler (using only SIGUSR1)</span>
<a name="l00193"></a>00193 <span class="comment"> * a global array is used to keep track of the interrupts that have been raised</span>
<a name="l00194"></a>00194 <span class="comment"> * further signals are block until interrupt handling has finished</span>
<a name="l00195"></a>00195 <span class="comment"> * thus, it may happen that an interrupt signal is silently ignored and never arrives here</span>
<a name="l00196"></a>00196 <span class="comment"> * the corresponding irq would never happen.</span>
<a name="l00197"></a>00197 <span class="comment"> * to avoid this, all interrupts marked in the interrupts_pending table are handled upon before</span>
<a name="l00198"></a>00198 <span class="comment"> * control is relinquished.</span>
<a name="l00199"></a>00199 <span class="comment"> * thus, an interrupt may be handled upon before it corresponding signal is received</span>
<a name="l00200"></a>00200 <span class="comment"> * and its "real" signal is processed - too early, so to say.</span>
<a name="l00201"></a>00201 <span class="comment"> * it doesn't matter, even if the signal is still received as the interrupts_pending table</span>
<a name="l00202"></a>00202 <span class="comment"> * will be empty.</span>
<a name="l00203"></a>00203 <span class="comment"> * </span>
<a name="l00204"></a>00204 <span class="comment"> */</span>
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="keyword">static</span> <span class="keywordtype">void</span> NutUnixInterruptScheduler(<span class="keywordtype">int</span>);
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keywordtype">void</span> NutUnixInterruptScheduler(<span class="keywordtype">int</span> signal)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209     <span class="keywordtype">int</span> irq;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="comment">// disable interrupts for interrupt processing</span>
<a name="l00212"></a>00212     pthread_sigmask(SIG_BLOCK, &amp;irq_signal, 0);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="comment">// call interrupt handler</span>
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (irq_current != irq_slot) {
<a name="l00216"></a>00216         irq = interrupts_pending[irq_current];
<a name="l00217"></a>00217         <span class="keywordflow">if</span> (++irq_current &gt;= <a class="code" href="arch_2unix_2os_2nutinit_8c.html#158a7fd99e424e9710b04659a6e9ea6b">MAX_IRQ_SLOTS</a>)
<a name="l00218"></a>00218             irq_current = 0;
<a name="l00219"></a>00219         <span class="keywordflow">if</span> (irq &lt; <a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>) {
<a name="l00220"></a>00220             <span class="keywordflow">if</span> (irq_handlers[irq].ir_handler) {
<a name="l00221"></a>00221                 irq_handlers[irq].<a class="code" href="struct_i_r_q___h_a_n_d_l_e_r.html#8d8231c9e42160b6439b2f10b2e307f6">ir_handler</a>(irq_handlers[irq].ir_arg);
<a name="l00222"></a>00222             }
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225     <span class="comment">// re-enable interrupts</span>
<a name="l00226"></a>00226     pthread_sigmask(SIG_UNBLOCK, &amp;irq_signal, 0);
<a name="l00227"></a>00227 }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 
<a name="l00244"></a>00244 <span class="keyword">extern</span> <a class="code" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> <a class="code" href="group__xg_timer.html#g9daf6de56d3a057c4146046229f5bb4c" title="Emulate a Nut hardware interrupt on Unix.">nut_ticks</a>;
<a name="l00245"></a>00245 <span class="keywordtype">void</span> <a class="code" href="arch_2unix_2irqreg_8h.html#2ca522d25019f19cddf5df7a8d36d830">NutUnixRaiseInterrupt</a>(<span class="keywordtype">int</span>);
<a name="l00246"></a><a class="code" href="arch_2unix_2irqreg_8h.html#2ca522d25019f19cddf5df7a8d36d830">00246</a> <span class="keywordtype">void</span> <a class="code" href="arch_2unix_2irqreg_8h.html#2ca522d25019f19cddf5df7a8d36d830">NutUnixRaiseInterrupt</a>(<span class="keywordtype">int</span> irq)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248     <span class="keywordtype">int</span> r;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="comment">// is there a slot available in our list of pending interrupts?</span>
<a name="l00252"></a>00252     <span class="comment">// if so, let signal handler know the type of interrupt</span>
<a name="l00253"></a>00253     <span class="keywordflow">if</span> ((irq_current == 0 &amp;&amp; irq_slot != <a class="code" href="arch_2unix_2os_2nutinit_8c.html#158a7fd99e424e9710b04659a6e9ea6b">MAX_IRQ_SLOTS</a> - 1) || (irq_current != 0 &amp;&amp; irq_slot != irq_current - 1)) {
<a name="l00254"></a>00254         <span class="comment">// make sure we're the only one manipulating the IRQ table</span>
<a name="l00255"></a>00255         pthread_mutex_lock(&amp;pending_mutex);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         interrupts_pending[irq_slot] = irq;
<a name="l00258"></a>00258         <span class="keywordflow">if</span> (++irq_slot &gt;= <a class="code" href="arch_2unix_2os_2nutinit_8c.html#158a7fd99e424e9710b04659a6e9ea6b">MAX_IRQ_SLOTS</a>) {
<a name="l00259"></a>00259             irq_slot = 0;
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261 <span class="preprocessor">#if 0</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( (nut_ticks % 1000) == 0 )
<a name="l00263"></a>00263             <a class="code" href="icc_8h.html#3cb9f0894fab1c8fbb0753c9c7c2a8d9" title="Specify enhanced AVR target.">printf</a>( <span class="stringliteral">"%u\n"</span>, nut_ticks );
<a name="l00264"></a>00264 <span class="preprocessor">#endif</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span>        pthread_mutex_unlock(&amp;pending_mutex);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267         <span class="comment">// signal interrupt thread to interrupt Nut threads</span>
<a name="l00268"></a>00268         r = pthread_cond_signal(&amp;pending_cv);
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 
<a name="l00295"></a><a class="code" href="arch_2unix_2os_2nutinit_8c.html#44c2292bed7d46631ae20ffdcfd696c1">00295</a> <span class="keywordtype">void</span> *<a class="code" href="arch_2unix_2os_2nutinit_8c.html#44c2292bed7d46631ae20ffdcfd696c1" title="Send emulated interrupt signal to Nut threads.">NutInterruptEmulation</a>(<span class="keywordtype">void</span> *unused_arg)
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297     <span class="comment">// non-nut thread =&gt; not interested in SIGUSR1 (IRQ signals)</span>
<a name="l00298"></a>00298     pthread_sigmask(SIG_BLOCK, &amp;irq_signal, 0);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="keywordflow">for</span> (;;) {
<a name="l00301"></a>00301         pthread_mutex_lock(&amp;pending_mutex);
<a name="l00302"></a>00302         <span class="keywordflow">while</span> (irq_slot == irq_sent) {
<a name="l00303"></a>00303             <span class="comment">// instead of busy waiting, let interrupting thread wake us</span>
<a name="l00304"></a>00304             pthread_cond_wait(&amp;pending_cv, &amp;pending_mutex);
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306         pthread_mutex_unlock(&amp;pending_mutex);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="comment">// interrupt pending ?</span>
<a name="l00309"></a>00309         <span class="keywordflow">if</span> (irq_slot != irq_sent) {
<a name="l00310"></a>00310             pthread_mutex_lock(&amp;irq_mutex);
<a name="l00311"></a>00311             <span class="comment">// instead of busy waiting, let Nut thread wake us once interrupts have been re-enabled</span>
<a name="l00312"></a>00312             <span class="keywordflow">while</span> (int_disabled == 1) {
<a name="l00313"></a>00313                 pthread_cond_wait(&amp;irq_cv, &amp;irq_mutex);
<a name="l00314"></a>00314             }
<a name="l00315"></a>00315             <span class="comment">// signal NUT thread, same effect as hardware interrupt</span>
<a name="l00316"></a>00316             kill(-getpgrp(), SIGUSR1);
<a name="l00317"></a>00317             irq_sent = irq_slot;
<a name="l00318"></a>00318             pthread_mutex_unlock(&amp;irq_mutex);
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordflow">return</span> NULL;
<a name="l00322"></a>00322 }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="comment">/*</span>
<a name="l00325"></a>00325 <span class="comment"> * Init IRQ handling</span>
<a name="l00326"></a>00326 <span class="comment"> *</span>
<a name="l00327"></a>00327 <span class="comment"> */</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="keyword">static</span> <span class="keywordtype">void</span> NutIRQInit(<span class="keywordtype">void</span>);
<a name="l00330"></a>00330 <span class="keyword">static</span> <span class="keywordtype">void</span> NutIRQInit()
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332     <span class="keywordtype">int</span> irq;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     <span class="comment">/* enable interrupts */</span>
<a name="l00335"></a>00335     int_disabled = 0;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     <span class="comment">// initialize interrupt type table</span>
<a name="l00338"></a>00338     irq_current = 0;
<a name="l00339"></a>00339     irq_slot = 0;
<a name="l00340"></a>00340     irq_sent = 0;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342     <span class="comment">// clear async event postings</span>
<a name="l00343"></a>00343     <span class="keywordflow">for</span> (irq = 0; irq &lt; <a class="code" href="unix_8h.html#06fc87d81c62e9abb8790b6e5713c55b2b50c30585046b622e2eec7a16b60f22">IRQ_MAX</a>; irq++)
<a name="l00344"></a>00344         irq_eventqueues[irq] = 0;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     <span class="comment">// define our IRQ signal</span>
<a name="l00347"></a>00347     sigemptyset(&amp;irq_signal);
<a name="l00348"></a>00348     sigaddset(&amp;irq_signal, SIGUSR1);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="comment">// the signal/IRQ handler</span>
<a name="l00351"></a>00351     signal(SIGUSR1, NutUnixInterruptScheduler);
<a name="l00352"></a>00352     signal(SIGINT, NutUnixControlC);    <span class="comment">// catch SIGINT (abort) to restore terminal</span>
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="comment">// synchronization tools</span>
<a name="l00355"></a>00355     pthread_mutex_init(&amp;irq_mutex, NULL);       <span class="comment">// enable/disable interrupts</span>
<a name="l00356"></a>00356     irq = pthread_cond_init(&amp;irq_cv, NULL);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     irq = pthread_mutex_init(&amp;pending_mutex, NULL);     <span class="comment">// maintenance of internal pending interrupts table</span>
<a name="l00359"></a>00359     irq = pthread_cond_init(&amp;pending_cv, NULL);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <span class="comment">// start interrupt emulation thread</span>
<a name="l00362"></a>00362     pthread_create(&amp;interrupt_thread, NULL, <a class="code" href="arch_2unix_2os_2nutinit_8c.html#44c2292bed7d46631ae20ffdcfd696c1" title="Send emulated interrupt signal to Nut threads.">NutInterruptEmulation</a>, (<span class="keywordtype">void</span> *) (<span class="keywordtype">void</span> *) NULL);
<a name="l00363"></a>00363 }
<a name="l00364"></a>00364 
<a name="l00369"></a>00369 
<a name="l00376"></a><a class="code" href="group__xg_nut_arch_unix_init.html#ge0d80557ad7151f89d27b93267f49aba">00376</a> <a class="code" href="thread_8h.html#9e196c330bbf6578b06f412df8d19f4c" title="Macro for thread entry definitions.">THREAD</a>(<a class="code" href="group__xg_nut_arch_avr_init.html#ge0d80557ad7151f89d27b93267f49aba" title="AVR Idle thread.">NutIdle</a>, arg)
<a name="l00377"></a>00377 {
<a name="l00378"></a>00378     <span class="comment">/* Initialize system timers. */</span>
<a name="l00379"></a>00379     <a class="code" href="group__xg_timer.html#g063e0628286de93e67e90fd168681aae" title="Initialize system timer.">NutTimerInit</a>();
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="comment">/* Create the main application thread. */</span>
<a name="l00382"></a>00382     <a class="code" href="group__xg_nut_arch_avr_os_context_gcc.html#g8357f2631f0c0a9444844e5ea64be50d" title="Create a new thread.">NutThreadCreate</a>(<span class="stringliteral">"main"</span>, <a class="code" href="group__xg_nut_arch_avr_init.html#gc03aa223c3c963c66026efcfbd8503d7">NutAppMain</a>, 0, <a class="code" href="group__xg_nut_arch_avr_init.html#g3e4d60795d76e168a6756f9b12c53431">NUT_THREAD_MAINSTACK</a>);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384     <span class="comment">// printf("main task created, idling now..\n");</span>
<a name="l00385"></a>00385     <span class="comment">/*</span>
<a name="l00386"></a>00386 <span class="comment">     * Run in an idle loop at the lowest priority. We can still</span>
<a name="l00387"></a>00387 <span class="comment">     * do something useful here, like killing terminated threads</span>
<a name="l00388"></a>00388 <span class="comment">     * or putting the CPU into sleep mode.</span>
<a name="l00389"></a>00389 <span class="comment">     */</span>
<a name="l00390"></a>00390     <a class="code" href="group__xg_thread.html#g8ebe134e9c404072584e80fb8d7e8985" title="Set the current thread&amp;#39;s priority.">NutThreadSetPriority</a>(254);
<a name="l00391"></a>00391     <span class="keywordflow">for</span> (;;) {
<a name="l00392"></a>00392         <a class="code" href="group__xg_thread.html#g075836f9a2596c5983b7ba88420afd11" title="Give up the CPU.">NutThreadYield</a>();
<a name="l00393"></a>00393         <a class="code" href="group__xg_thread.html#gba085dddcb4bf80a0b246bd06618d740" title="Free a thread that was previously killed and release memory back to the OS.">NutThreadDestroy</a>();
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <span class="comment">// sleep(); ... sleeping would be fine.</span>
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00406"></a>00406 <span class="preprocessor">#undef main</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>
<a name="l00408"></a><a class="code" href="group__xg_nut_arch_unix_init.html#g9a955d4107be186c9724bc0236aed127">00408</a> <span class="preprocessor">#define PSEUDO_RAM_SIZE 999999</span>
<a name="l00409"></a><a class="code" href="group__xg_nut_arch_unix_init.html#gee24c5664be5f75688b2dd3f282d9241">00409</a> <span class="preprocessor"></span><a class="code" href="stdint_8h.html#ba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="code" href="group__xg_nut_arch_unix_init.html#gee24c5664be5f75688b2dd3f282d9241">PSEUDO_RAM</a>[<a class="code" href="group__xg_nut_arch_unix_init.html#g9a955d4107be186c9724bc0236aed127" title="Nut/OS Initialization.">PSEUDO_RAM_SIZE</a>];
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__xg_nut_arch_unix_os_context.html#gb455d63a630ebab93f2f2753df39185e">NutThreadInit</a>(<span class="keywordtype">void</span>);
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="keyword">extern</span> NUTFILE *<a class="code" href="group__xg_nut_arch_unix_init.html#ge5ce834617b385d2089d68954ee5ac2a">NUT_freopen</a>(<a class="code" href="arm_8h.html#0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <span class="keywordtype">char</span> *name, <a class="code" href="arm_8h.html#0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <span class="keywordtype">char</span> *mode, NUTFILE * stream);
<a name="l00414"></a>00414 <span class="keyword">extern</span> NUTFILE *<a class="code" href="group__xg_crt_stdio.html#ge6cd961b9780bc03542112f6b123c079">__iob</a>[];
<a name="l00415"></a>00415 
<a name="l00416"></a><a class="code" href="group__xg_nut_arch_unix_init.html#g0ddf1224851353fc92bfbff6f499fa97">00416</a> <span class="keywordtype">int</span> <a class="code" href="arm_8h.html#a4e97f3782107649d3e4eb3875090b3a">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
<a name="l00417"></a>00417 {
<a name="l00418"></a>00418     tcgetattr(fileno(<a class="code" href="group__xg_crt_stdio.html#g0c0ef221f95f64e8632451312fd18cc8" title="Standard output stream.">stdout</a>), &amp;<a class="code" href="unix_8h.html#d0d96d193a75cdbe5630643d12c49503">emulation_options</a>.<a class="code" href="structemulation__options__t.html#a46a37a952cd24d84649ae775eeac175">saved_termios</a>);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="comment">/* get command line options */</span>
<a name="l00421"></a>00421     <a class="code" href="unix_8h.html#81ea34179659fcde59b1f4157b28ec8f">emulation_options_parse</a>(argc, argv);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">/*</span>
<a name="l00424"></a>00424 <span class="comment">     * Register our Pseudo RAM</span>
<a name="l00425"></a>00425 <span class="comment">     */</span>
<a name="l00426"></a>00426     <a class="code" href="heap_8h.html#18968719e49243588cf45ed06bc459b2">NutHeapAdd</a>(PSEUDO_RAM, <a class="code" href="group__xg_nut_arch_unix_init.html#g9a955d4107be186c9724bc0236aed127" title="Nut/OS Initialization.">PSEUDO_RAM_SIZE</a>);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">/* Read OS configuration from non-volatile memory. */</span>
<a name="l00429"></a>00429     <a class="code" href="group__xg_conf_os.html#gbca7504d210e24288104af136b2b6968" title="Load Nut/OS configuration from non-volatile memory.">NutLoadConfig</a>();
<a name="l00430"></a>00430 
<a name="l00431"></a>00431     <span class="comment">/*</span>
<a name="l00432"></a>00432 <span class="comment">     * set stdio</span>
<a name="l00433"></a>00433 <span class="comment">     */</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     <span class="comment">/*</span>
<a name="l00436"></a>00436 <span class="comment">       NutRegisterDevice(&amp;devUart0, 0, 0);</span>
<a name="l00437"></a>00437 <span class="comment">       NUT_freopen("uart0", "w", __iob[1]);</span>
<a name="l00438"></a>00438 <span class="comment">       printf("OS Debug Mode, stdout opened in unix_nutinit.c\n");</span>
<a name="l00439"></a>00439 <span class="comment">       // NutTraceOs( stdout, 1);</span>
<a name="l00440"></a>00440 <span class="comment">     */</span>
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     <span class="comment">/*</span>
<a name="l00443"></a>00443 <span class="comment">     * Init interrupt handling</span>
<a name="l00444"></a>00444 <span class="comment">     */</span>
<a name="l00445"></a>00445     NutIRQInit();
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     <span class="comment">/*</span>
<a name="l00448"></a>00448 <span class="comment">     * Init threading</span>
<a name="l00449"></a>00449 <span class="comment">     */</span>
<a name="l00450"></a>00450     <a class="code" href="group__xg_nut_arch_unix_os_context.html#gb455d63a630ebab93f2f2753df39185e">NutThreadInit</a>();
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <span class="comment">/*</span>
<a name="l00453"></a>00453 <span class="comment">     * Create idle thread</span>
<a name="l00454"></a>00454 <span class="comment">     */</span>
<a name="l00455"></a>00455     <a class="code" href="group__xg_nut_arch_avr_os_context_gcc.html#g8357f2631f0c0a9444844e5ea64be50d" title="Create a new thread.">NutThreadCreate</a>(<span class="stringliteral">"idle"</span>, <a class="code" href="group__xg_nut_arch_avr_init.html#ge0d80557ad7151f89d27b93267f49aba" title="AVR Idle thread.">NutIdle</a>, 0, <a class="code" href="group__xg_nut_arch_avr_init.html#ge8b04c1eee99e2b3501a0361d397bd20">NUT_THREAD_IDLESTACK</a>);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457     <span class="keywordflow">return</span> 0;
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
</pre></div></div>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2007 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
