<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
    <link href="nut_entabs.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>AHDLC<br>
<small>
[<a class="el" href="group__xg_nut_arch_avr_dev_serial.html">Serial</a>]</small>
</h1>AHDLC Driver.  
<a href="#_details">More...</a>
<p>

<p>
<div class="dynheader">
Collaboration diagram for AHDLC:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__xg_ahdlc_avr.png" border="0" alt="" usemap="#group____xg__ahdlc__avr_map">
<map name="group____xg__ahdlc__avr_map">
<area shape="rect" href="group__xg_nut_arch_avr_dev_serial.html" title="AVR drivers for serial communication." alt="Serial" coords="17,5,63,26"></map></td></tr></table></center>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gc6ca36bfaaa9b1e29bd4eba07c5d97e2">IN_ACC_MAP</a>(c, m)&nbsp;&nbsp;&nbsp;(( ((<a class="el" href="group__xg_crt_string.html#gba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>) (c)) &lt; 0x20)  &amp;&amp; ((m) &amp; (1UL &lt;&lt; (c))) != 0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gac9673f0192fbe2b9a222ac01f04f9cb">NUT_THREAD_AHDLCRXSTACK</a>&nbsp;&nbsp;&nbsp;512</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gc6ca36bfaaa9b1e29bd4eba07c5d97e2">IN_ACC_MAP</a>(c, m)&nbsp;&nbsp;&nbsp;(( ((<a class="el" href="group__xg_crt_string.html#gba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>) (c)) &lt; 0x20)  &amp;&amp; ((m) &amp; (1UL &lt;&lt; (c))) != 0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gac9673f0192fbe2b9a222ac01f04f9cb">NUT_THREAD_AHDLCRXSTACK</a>&nbsp;&nbsp;&nbsp;2048</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g5b7e2abea3327c269e736d3b30cb63ba">AhdlcOutput</a> (NUTDEVICE *dev, NETBUF *nb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send HDLC frame.  <a href="#g5b7e2abea3327c269e736d3b30cb63ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g784911921399d46c79de66de68b9d79a">AhdlcRx</a> (void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronous HDLC receiver thread.  <a href="#g784911921399d46c79de66de68b9d79a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#ge1493fe9d0ae191af622b1f3d42441ef">AhdlcAvrIOCtl</a> (NUTDEVICE *dev, int req, void *conf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform on-chip UART control functions.  <a href="#ge1493fe9d0ae191af622b1f3d42441ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gb82851594ae03aa1f852037435288420">AhdlcAvrInit</a> (NUTDEVICE *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize asynchronous HDLC device.  <a href="#gb82851594ae03aa1f852037435288420"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#ge1a62da30e9d1821a97a42c757be8358">AhdlcAvrRead</a> (NUTFILE *fp, void *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from the asynchronous HDLC device.  <a href="#ge1a62da30e9d1821a97a42c757be8358"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g76ea23685b1266488c9119efff5477a1">AhdlcAvrPut</a> (NUTDEVICE *dev, CONST void *buffer, int len, int pflg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to the asynchronous HDLC device.  <a href="#g76ea23685b1266488c9119efff5477a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g6658a32c5b87c6341b4ccd91f2e2b853">AhdlcAvrWrite</a> (NUTFILE *fp, CONST void *buffer, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to the asynchronous HDLC device.  <a href="#g6658a32c5b87c6341b4ccd91f2e2b853"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g33edc97cae8b172b0e3ccb2e2ede4864">AhdlcAvrWrite_P</a> (NUTFILE *fp, PGM_P buffer, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to the asynchronous HDLC device.  <a href="#g33edc97cae8b172b0e3ccb2e2ede4864"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NUTFILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g14922325c9ea0499e4215cfb5ee89cea">AhdlcAvrOpen</a> (NUTDEVICE *dev, CONST char *name, int mode, int acc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the asynchronous HDLC device.  <a href="#g14922325c9ea0499e4215cfb5ee89cea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g6d1fc092de41db6067e61771c1f21943">AhdlcAvrClose</a> (NUTFILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the asynchronous HDLC device.  <a href="#g6d1fc092de41db6067e61771c1f21943"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g5cc7ba613a1788ffe7096bb3280ce043">AhdlcAt91IOCtl</a> (NUTDEVICE *dev, int req, void *conf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform on-chip UART control functions.  <a href="#g5cc7ba613a1788ffe7096bb3280ce043"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gdfa27b86eebd5208460d67698f1edf34">AhdlcAt91Init</a> (NUTDEVICE *dev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize asynchronous HDLC device.  <a href="#gdfa27b86eebd5208460d67698f1edf34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gba4aefd965ac68263cfa5395c8968f6c">AhdlcAt91Read</a> (NUTFILE *fp, void *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from the asynchronous HDLC device.  <a href="#gba4aefd965ac68263cfa5395c8968f6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g9d948ff25fca454107e921777c7d66d2">AhdlcAt91Put</a> (NUTDEVICE *dev, CONST void *buffer, int len, int pflg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to the asynchronous HDLC device.  <a href="#g9d948ff25fca454107e921777c7d66d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gdb50c3ce74b373bee474d1e0b3275e90">AhdlcAt91Write</a> (NUTFILE *fp, CONST void *buffer, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to the asynchronous HDLC device.  <a href="#gdb50c3ce74b373bee474d1e0b3275e90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g0fb0cb74853d071540e3ba8e65dc63a1">AhdlcAt91Write_P</a> (NUTFILE *fp, PGM_P buffer, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to the asynchronous HDLC device.  <a href="#g0fb0cb74853d071540e3ba8e65dc63a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NUTFILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g9cdbdf33ba1fc4e8a5951d7205a0ba7a">AhdlcAt91Open</a> (NUTDEVICE *dev, CONST char *name, int mode, int acc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the asynchronous HDLC device.  <a href="#g9cdbdf33ba1fc4e8a5951d7205a0ba7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g28455b93bc5ead8fddafbfc02da2d6ce">AhdlcAt91Close</a> (NUTFILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the asynchronous HDLC device.  <a href="#g28455b93bc5ead8fddafbfc02da2d6ce"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NUTDEVICE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#g2055414d977913bf74d19aaa8519fe3f">devAhdlc0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device information structure.  <a href="#g2055414d977913bf74d19aaa8519fe3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NUTDEVICE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gda2d8862571cf916513439d0619bd69d">devAhdlc1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device information structure.  <a href="#gda2d8862571cf916513439d0619bd69d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NUTDEVICE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_ahdlc_avr.html#gda2d8862571cf916513439d0619bd69d">devAhdlc1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device information structure.  <a href="#gda2d8862571cf916513439d0619bd69d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
AHDLC Driver. 
<p>
This code contains a modified UART driver with some speed optimizations for PPP, like table driven FCS calculation. It also implements simple modem handshaking (RTS, CTS and DTR). <hr><h2>Define Documentation</h2>
<a class="anchor" name="gc6ca36bfaaa9b1e29bd4eba07c5d97e2"></a><!-- doxytag: member="ahdlcavr.c::IN_ACC_MAP" ref="gc6ca36bfaaa9b1e29bd4eba07c5d97e2" args="(c, m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IN_ACC_MAP          </td>
          <td>(</td>
          <td class="paramtype">c,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(( ((<a class="el" href="group__xg_crt_string.html#gba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>) (c)) &lt; 0x20)  &amp;&amp; ((m) &amp; (1UL &lt;&lt; (c))) != 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks the 32-bit ACCM to see if the byte needs un-escaping 
<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l00156">156</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gac9673f0192fbe2b9a222ac01f04f9cb"></a><!-- doxytag: member="ahdlcavr.c::NUT_THREAD_AHDLCRXSTACK" ref="gac9673f0192fbe2b9a222ac01f04f9cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUT_THREAD_AHDLCRXSTACK&nbsp;&nbsp;&nbsp;512          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l00159">159</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>Referenced by <a class="el" href="at91__ahdlc_8c-source.html#l00879">AhdlcAt91Init()</a>, and <a class="el" href="ahdlcavr_8c-source.html#l01029">AhdlcAvrInit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc6ca36bfaaa9b1e29bd4eba07c5d97e2"></a><!-- doxytag: member="at91_ahdlc.c::IN_ACC_MAP" ref="gc6ca36bfaaa9b1e29bd4eba07c5d97e2" args="(c, m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IN_ACC_MAP          </td>
          <td>(</td>
          <td class="paramtype">c,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(( ((<a class="el" href="group__xg_crt_string.html#gba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>) (c)) &lt; 0x20)  &amp;&amp; ((m) &amp; (1UL &lt;&lt; (c))) != 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks the 32-bit ACCM to see if the byte needs un-escaping 
<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l00170">170</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gac9673f0192fbe2b9a222ac01f04f9cb"></a><!-- doxytag: member="at91_ahdlc.c::NUT_THREAD_AHDLCRXSTACK" ref="gac9673f0192fbe2b9a222ac01f04f9cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUT_THREAD_AHDLCRXSTACK&nbsp;&nbsp;&nbsp;2048          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l00173">173</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g5b7e2abea3327c269e736d3b30cb63ba"></a><!-- doxytag: member="ahdlcavr.c::AhdlcOutput" ref="g5b7e2abea3327c269e736d3b30cb63ba" args="(NUTDEVICE *dev, NETBUF *nb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcOutput           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NETBUF *&nbsp;</td>
          <td class="paramname"> <em>nb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send HDLC frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Identifies the device to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb</em>&nbsp;</td><td>Network buffer structure containing the packet to be sent. The structure must have been allocated by a previous call <a class="el" href="group__xgnetbuf.html#g7a733aed1e6c15aaabb6657abe5f4e39" title="Allocate or re-allocate a network buffer part.">NutNetBufAlloc()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 in case of any errors. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l00352">352</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="dev_2ahdlc_8h-source.html#l00066">AHDLC_FLAG</a>, <a class="el" href="dev_2ahdlc_8h-source.html#l00073">AHDLC_INITFCS</a>, and <a class="el" href="uartavr_8h-source.html#l00111">UART_MF_RAWMODE</a>.</p>

<p>Referenced by <a class="el" href="ahdlcavr_8c-source.html#l00407">AhdlcRx()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g784911921399d46c79de66de68b9d79a"></a><!-- doxytag: member="ahdlcavr.c::AhdlcRx" ref="g784911921399d46c79de66de68b9d79a" args="(void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AhdlcRx           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous HDLC receiver thread. 
<p>
Running at high priority. 
<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l00407">407</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="dev_2ahdlc_8h-source.html#l00067">AHDLC_ESCAPE</a>, <a class="el" href="dev_2ahdlc_8h-source.html#l00066">AHDLC_FLAG</a>, <a class="el" href="dev_2ahdlc_8h-source.html#l00074">AHDLC_GOODFCS</a>, <a class="el" href="dev_2ahdlc_8h-source.html#l00073">AHDLC_INITFCS</a>, <a class="el" href="dev_2ahdlc_8h-source.html#l00068">AHDLC_TRANS</a>, <a class="el" href="ahdlcavr_8c-source.html#l00352">AhdlcOutput()</a>, <a class="el" href="dev_2ppp_8h-source.html#l00262">LCP_LOWERDOWN</a>, <a class="el" href="dev_2ppp_8h-source.html#l00261">LCP_LOWERUP</a>, <a class="el" href="memcpy_8c-source.html#l00114">memcpy()</a>, <a class="el" href="netbuf_8h-source.html#l00129">NBAF_DATALINK</a>, <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, <a class="el" href="netbuf_8c-source.html#l00173">NutNetBufAlloc()</a>, <a class="el" href="timer_8c-source.html#l00610">NutSleep()</a>, <a class="el" href="os_2thread_8c-source.html#l00518">NutThreadSetPriority()</a>, <a class="el" href="arm_8h-source.html#l00155">PRG_RDB</a>, and <a class="el" href="uartavr_8h-source.html#l00111">UART_MF_RAWMODE</a>.</p>

<p>Referenced by <a class="el" href="at91__ahdlc_8c-source.html#l00879">AhdlcAt91Init()</a>, and <a class="el" href="ahdlcavr_8c-source.html#l01029">AhdlcAvrInit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge1493fe9d0ae191af622b1f3d42441ef"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrIOCtl" ref="ge1493fe9d0ae191af622b1f3d42441ef" args="(NUTDEVICE *dev, int req, void *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrIOCtl           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform on-chip UART control functions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Identifies the device that receives the device-control function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Requested control function. May be set to one of the following constants:<ul>
<li>UART_SETSPEED, conf points to an uint32_t value containing the baudrate.</li><li>UART_GETSPEED, conf points to an uint32_t value receiving the current baudrate.</li><li>UART_SETDATABITS, conf points to an uint32_t value containing the number of data bits, 5, 6, 7 or 8.</li><li>UART_GETDATABITS, conf points to an uint32_t value receiving the number of data bits, 5, 6, 7 or 8.</li><li>UART_SETPARITY, conf points to an uint32_t value containing the parity, 0 (no), 1 (odd) or 2 (even).</li><li>UART_GETPARITY, conf points to an uint32_t value receiving the parity, 0 (no), 1 (odd) or 2 (even).</li><li>UART_SETSTOPBITS, conf points to an uint32_t value containing the number of stop bits 1 or 2.</li><li>UART_GETSTOPBITS, conf points to an uint32_t value receiving the number of stop bits 1 or 2.</li><li>UART_SETSTATUS, conf points to an uint32_t value containing the changes for the control lines.</li><li>UART_GETSTATUS, conf points to an uint32_t value receiving the state of the control lines and the device.</li><li>UART_SETREADTIMEOUT, conf points to an uint32_t value containing the read timeout.</li><li>UART_GETREADTIMEOUT, conf points to an uint32_t value receiving the read timeout.</li><li>UART_SETWRITETIMEOUT, conf points to an uint32_t value containing the write timeout.</li><li>UART_GETWRITETIMEOUT, conf points to an uint32_t value receiving the write timeout.</li><li>UART_SETLOCALECHO, conf points to an uint32_t value containing 0 (off) or 1 (on).</li><li>UART_GETLOCALECHO, conf points to an uint32_t value receiving 0 (off) or 1 (on).</li><li>UART_SETFLOWCONTROL, conf points to an uint32_t value containing combined UART_FCTL_ values.</li><li>UART_GETFLOWCONTROL, conf points to an uint32_t value containing receiving UART_FCTL_ values.</li><li>UART_SETCOOKEDMODE, conf points to an uint32_t value containing 0 (off) or 1 (on).</li><li>UART_GETCOOKEDMODE, conf points to an uint32_t value receiving 0 (off) or 1 (on).</li><li>UART_SETRAWMODE, conf points to an uint32_t value containing 0 (off) or 1 (on).</li><li>UART_GETRAWMODE, conf points to an uint32_t value receiving 0 (off) or 1 (on).</li><li>HDLC_SETIFNET, conf points to a pointer containing the address of the network device's NUTDEVICE structure.</li><li>HDLC_GETIFNET, conf points to a pointer receiving the address of the network device's NUTDEVICE structure.</li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Points to a buffer that contains any data required for the given control function or receives data from that function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Timeout values are given in milliseconds and are limited to the granularity of the system timer.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For ATmega103, only 8 data bits, 1 stop bit and no parity are allowed. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l00784">784</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="uart0_8c-source.html#l00076">devUart0</a>, <a class="el" href="dev_2uart_8h-source.html#l00260">HDLC_GETIFNET</a>, <a class="el" href="dev_2uart_8h-source.html#l00254">HDLC_SETIFNET</a>, <a class="el" href="device_8h-source.html#l00140">IFTYP_CHAR</a>, <a class="el" href="device_8h-source.html#l00138">IFTYP_NET</a>, <a class="el" href="icc_8h-source.html#l00283">inp</a>, <a class="el" href="event_8c-source.html#l00454">NutEventPost()</a>, <a class="el" href="timer_8c-source.html#l00800">NutGetCpuClock()</a>, <a class="el" href="icc_8h-source.html#l00280">outp</a>, <a class="el" href="dev_2uart_8h-source.html#l00130">UART_GETDATABITS</a>, <a class="el" href="dev_2uart_8h-source.html#l00222">UART_GETFLOWCONTROL</a>, <a class="el" href="dev_2uart_8h-source.html#l00210">UART_GETLOCALECHO</a>, <a class="el" href="dev_2uart_8h-source.html#l00144">UART_GETPARITY</a>, <a class="el" href="dev_2uart_8h-source.html#l00370">UART_GETRAWMODE</a>, <a class="el" href="dev_2uart_8h-source.html#l00182">UART_GETREADTIMEOUT</a>, <a class="el" href="dev_2uart_8h-source.html#l00116">UART_GETSPEED</a>, <a class="el" href="dev_2uart_8h-source.html#l00168">UART_GETSTATUS</a>, <a class="el" href="dev_2uart_8h-source.html#l00156">UART_GETSTOPBITS</a>, <a class="el" href="dev_2uart_8h-source.html#l00196">UART_GETWRITETIMEOUT</a>, <a class="el" href="scih8_8h-source.html#l00077">UART_MF_LOCALECHO</a>, <a class="el" href="uartavr_8h-source.html#l00111">UART_MF_RAWMODE</a>, <a class="el" href="dev_2uart_8h-source.html#l00123">UART_SETDATABITS</a>, <a class="el" href="dev_2uart_8h-source.html#l00216">UART_SETFLOWCONTROL</a>, <a class="el" href="dev_2uart_8h-source.html#l00203">UART_SETLOCALECHO</a>, <a class="el" href="dev_2uart_8h-source.html#l00137">UART_SETPARITY</a>, <a class="el" href="dev_2uart_8h-source.html#l00364">UART_SETRAWMODE</a>, <a class="el" href="dev_2uart_8h-source.html#l00175">UART_SETREADTIMEOUT</a>, <a class="el" href="dev_2uart_8h-source.html#l00109">UART_SETSPEED</a>, <a class="el" href="dev_2uart_8h-source.html#l00162">UART_SETSTATUS</a>, <a class="el" href="dev_2uart_8h-source.html#l00150">UART_SETSTOPBITS</a>, <a class="el" href="dev_2uart_8h-source.html#l00189">UART_SETWRITETIMEOUT</a>, and <a class="el" href="arch_2avr_8h-source.html#l00155">UBRR</a>.</p>

<p>Referenced by <a class="el" href="ahdlcavr_8c-source.html#l01029">AhdlcAvrInit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb82851594ae03aa1f852037435288420"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrInit" ref="gb82851594ae03aa1f852037435288420" args="(NUTDEVICE *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrInit           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize asynchronous HDLC device. 
<p>
This function will be called during device registration. It initializes the hardware, registers all required interrupt handlers and initializes all internal data structures used by this driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Identifies the device to initialize.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01029">1029</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="ahdlcavr_8c-source.html#l00784">AhdlcAvrIOCtl()</a>, <a class="el" href="ahdlcavr_8c-source.html#l00407">AhdlcRx()</a>, <a class="el" href="icc_8h-source.html#l00265">cbi</a>, <a class="el" href="arch_2avr_8h-source.html#l00164">EICR</a>, <a class="el" href="memset_8c-source.html#l00088">memset()</a>, <a class="el" href="ahdlcavr_8c-source.html#l00159">NUT_THREAD_AHDLCRXSTACK</a>, <a class="el" href="thread_8h-source.html#l00241">NUT_THREAD_STACK_ADD</a>, <a class="el" href="thread_8h-source.html#l00230">NUT_THREAD_STACK_MULT</a>, <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, <a class="el" href="ihndlr_8c-source.html#l00098">NutRegisterIrqHandler()</a>, <a class="el" href="context__gcc_8c-source.html#l00321">NutThreadCreate()</a>, <a class="el" href="icc_8h-source.html#l00266">sbi</a>, <a class="el" href="ih__usart0__udre_8c-source.html#l00099">sig_UART0_DATA</a>, <a class="el" href="ih__usart0__rx_8c-source.html#l00095">sig_UART0_RECV</a>, <a class="el" href="arch_2avr_2irqreg_8h.html#a58c018bef09371d118ed93100b93855">sig_UART1_DATA</a>, <a class="el" href="arch_2avr_2irqreg_8h.html#6f9e2f8fa51ba161dc2e38c56bd291a0">sig_UART1_RECV</a>, and <a class="el" href="dev_2uart_8h-source.html#l00109">UART_SETSPEED</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge1a62da30e9d1821a97a42c757be8358"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrRead" ref="ge1a62da30e9d1821a97a42c757be8358" args="(NUTFILE *fp, void *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrRead           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read from the asynchronous HDLC device. 
<p>
This function is called by the low level input routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#0b784cc08be2375571b449ebcb2663db" title="Read from device.">_NUTDEVICE::dev_read</a> entry.<p>
The function may block the calling thread until at least one character has been received or a timeout occurs.<p>
It is recommended to set a proper read timeout with software handshake. In this case a timeout may occur, if the communication peer lost our last XON character. The application may then use ioctl() to disable the receiver and do the read again. This will send out another XON.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct___n_u_t_f_i_l_e.html">_NUTFILE</a> structure, obtained by a previous call to AhdlcOpen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the buffer that receives the data. If zero, then all characters in the input buffer will be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Maximum number of bytes to read.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read, which may be less than the number of bytes specified. A return value of -1 indicates an error, while zero is returned in case of a timeout. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01168">1168</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g76ea23685b1266488c9119efff5477a1"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrPut" ref="g76ea23685b1266488c9119efff5477a1" args="(NUTDEVICE *dev, CONST void *buffer, int len, int pflg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrPut           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pflg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to the asynchronous HDLC device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Pointer to a previously registered NUTDEVICE structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer the data to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of data bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pflg</em>&nbsp;</td><td>If this flag is set, then the buffer is located in program space.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written. In case of a write timeout, this may be less than the specified length. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01208">1208</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="arm_8h-source.html#l00143">CONST</a>, <a class="el" href="arm_8h-source.html#l00155">PRG_RDB</a>, <a class="el" href="icc_8h-source.html#l00266">sbi</a>, <a class="el" href="arch_2avr_8h-source.html#l00161">UCR</a>, and <a class="el" href="arch_2avr_8h-source.html#l00185">UDRIE</a>.</p>

<p>Referenced by <a class="el" href="ahdlcavr_8c-source.html#l01262">AhdlcAvrWrite()</a>, and <a class="el" href="ahdlcavr_8c-source.html#l01288">AhdlcAvrWrite_P()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6658a32c5b87c6341b4ccd91f2e2b853"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrWrite" ref="g6658a32c5b87c6341b4ccd91f2e2b853" args="(NUTFILE *fp, CONST void *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrWrite           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to the asynchronous HDLC device. 
<p>
This function is called by the low level output routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#f4d266bf15c47743230962d9b960d24c">_NUTDEVICE::dev_write</a> entry.<p>
The function may block the calling thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct___n_u_t_f_i_l_e.html" title="File structure.">_NUTFILE</a> structure, obtained by a previous call to AhldcOpen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the data to be written. If zero, then the output buffer will be flushed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to write.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written, which may be less than the number of bytes specified if a timeout occured. A return value of -1 indicates an error. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01262">1262</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="ahdlcavr_8c-source.html#l01208">AhdlcAvrPut()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g33edc97cae8b172b0e3ccb2e2ede4864"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrWrite_P" ref="g33edc97cae8b172b0e3ccb2e2ede4864" args="(NUTFILE *fp, PGM_P buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrWrite_P           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to the asynchronous HDLC device. 
<p>
Similar to AhdlcWrite() except that the data is located in program memory.<p>
This function is called by the low level output routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#d8372c14180f06a336eafc0eb7683c8a" title="Write to device.">_NUTDEVICE::dev_write_P</a> entry.<p>
The function may block the calling thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a NUTFILE structure, obtained by a previous call to AhdlcOpen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the data in program space to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to write.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written, which may be less than the number of bytes specified if a timeout occured. A return value of -1 indicates an error. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01288">1288</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="ahdlcavr_8c-source.html#l01208">AhdlcAvrPut()</a>, and <a class="el" href="arm_8h-source.html#l00143">CONST</a>.</p>

</div>
</div><p>
<a class="anchor" name="g14922325c9ea0499e4215cfb5ee89cea"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrOpen" ref="g14922325c9ea0499e4215cfb5ee89cea" args="(NUTDEVICE *dev, CONST char *name, int mode, int acc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUTFILE* AhdlcAvrOpen           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>acc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the asynchronous HDLC device. 
<p>
This function is called by the low level open routine of the C runtime library, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#dcb423014f04b6ff69e5102291605adf" title="Open a device or file.">_NUTDEVICE::dev_open</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Pointer to the NUTDEVICE structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Ignored, should point to an empty string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Operation mode. Any of the following values may be or-ed:<ul>
<li><a class="el" href="group__xg_crt_lowio.html#g166a079a4990ddeb0a32475728bbacd0">_O_BINARY</a></li><li><a class="el" href="group__xg_crt_lowio.html#g4d457d93039cb26f27461c4af5868309">_O_RDONLY</a></li><li><a class="el" href="group__xg_crt_lowio.html#gc58f7734ab4dd8ae25bda2fba713ea56">_O_WRONLY</a> </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acc</em>&nbsp;</td><td>Ignored, should be zero.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to a NUTFILE structure if successful or NUTFILE_EOF otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01309">1309</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="icc_8h-source.html#l00265">cbi</a>, <a class="el" href="file_8h-source.html#l00088">NUTFILE_EOF</a>, and <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6d1fc092de41db6067e61771c1f21943"></a><!-- doxytag: member="ahdlcavr.c::AhdlcAvrClose" ref="g6d1fc092de41db6067e61771c1f21943" args="(NUTFILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAvrClose           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the asynchronous HDLC device. 
<p>
This function is called by the low level close routine of the C runtime library, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#8fd2505be5a63e619a059523eba40c57" title="Close a device or file.">_NUTDEVICE::dev_close</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct___n_u_t_f_i_l_e.html" title="File structure.">_NUTFILE</a> structure, obtained by a previous call to <a class="el" href="group__xg_usart.html#geb1a110892efd2c8c1c40d9a1602958a" title="Open an USART device.">UsartOpen()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or -1 otherwise.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>We may support shared open and use dev_irq as an open counter. </dd></dl>

<p>Definition at line <a class="el" href="ahdlcavr_8c-source.html#l01355">1355</a> of file <a class="el" href="ahdlcavr_8c-source.html">ahdlcavr.c</a>.</p>

<p>References <a class="el" href="file_8h-source.html#l00088">NUTFILE_EOF</a>, <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, and <a class="el" href="icc_8h-source.html#l00266">sbi</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5cc7ba613a1788ffe7096bb3280ce043"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91IOCtl" ref="g5cc7ba613a1788ffe7096bb3280ce043" args="(NUTDEVICE *dev, int req, void *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91IOCtl           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform on-chip UART control functions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Identifies the device that receives the device-control function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Requested control function. May be set to one of the following constants:<ul>
<li>UART_SETSPEED, conf points to an uint32_t value containing the baudrate.</li><li>UART_GETSPEED, conf points to an uint32_t value receiving the current baudrate.</li><li>UART_SETSTATUS, conf points to an uint32_t value containing the changes for the control lines.</li><li>UART_GETSTATUS, conf points to an uint32_t value receiving the state of the control lines and the device.</li><li>UART_SETREADTIMEOUT, conf points to an uint32_t value containing the read timeout.</li><li>UART_GETREADTIMEOUT, conf points to an uint32_t value receiving the read timeout.</li><li>UART_SETWRITETIMEOUT, conf points to an uint32_t value containing the write timeout.</li><li>UART_GETWRITETIMEOUT, conf points to an uint32_t value receiving the write timeout.</li><li>UART_SETLOCALECHO, conf points to an uint32_t value containing 0 (off) or 1 (on).</li><li>UART_GETLOCALECHO, conf points to an uint32_t value receiving 0 (off) or 1 (on).</li><li>UART_SETFLOWCONTROL, conf points to an uint32_t value containing combined UART_FCTL_ values.</li><li>UART_GETFLOWCONTROL, conf points to an uint32_t value containing receiving UART_FCTL_ values.</li><li>UART_SETCOOKEDMODE, conf points to an uint32_t value containing 0 (off) or 1 (on).</li><li>UART_GETCOOKEDMODE, conf points to an uint32_t value receiving 0 (off) or 1 (on).</li><li>UART_SETRAWMODE, conf points to an uint32_t value containing 0 (off) or 1 (on).</li><li>UART_GETRAWMODE, conf points to an uint32_t value receiving 0 (off) or 1 (on).</li><li>HDLC_SETIFNET, conf points to a pointer containing the address of the network device's NUTDEVICE structure.</li><li>HDLC_GETIFNET, conf points to a pointer receiving the address of the network device's NUTDEVICE structure.</li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Points to a buffer that contains any data required for the given control function or receives data from that function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Timeout values are given in milliseconds and are limited to the granularity of the system timer.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For ATmega103, only 8 data bits, 1 stop bit and no parity are allowed. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l00729">729</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="usart0at91_8c-source.html#l00166">devUsartAt910</a>, <a class="el" href="dev_2uart_8h-source.html#l00260">HDLC_GETIFNET</a>, <a class="el" href="dev_2uart_8h-source.html#l00254">HDLC_SETIFNET</a>, <a class="el" href="device_8h-source.html#l00140">IFTYP_CHAR</a>, <a class="el" href="device_8h-source.html#l00138">IFTYP_NET</a>, <a class="el" href="arm_8h-source.html#l00199">inr</a>, <a class="el" href="event_8c-source.html#l00454">NutEventPost()</a>, <a class="el" href="timer_8c-source.html#l00800">NutGetCpuClock()</a>, <a class="el" href="arm_8h-source.html#l00195">outr</a>, <a class="el" href="dev_2uart_8h-source.html#l00222">UART_GETFLOWCONTROL</a>, <a class="el" href="dev_2uart_8h-source.html#l00210">UART_GETLOCALECHO</a>, <a class="el" href="dev_2uart_8h-source.html#l00370">UART_GETRAWMODE</a>, <a class="el" href="dev_2uart_8h-source.html#l00182">UART_GETREADTIMEOUT</a>, <a class="el" href="dev_2uart_8h-source.html#l00116">UART_GETSPEED</a>, <a class="el" href="dev_2uart_8h-source.html#l00168">UART_GETSTATUS</a>, <a class="el" href="dev_2uart_8h-source.html#l00196">UART_GETWRITETIMEOUT</a>, <a class="el" href="scih8_8h-source.html#l00077">UART_MF_LOCALECHO</a>, <a class="el" href="uartavr_8h-source.html#l00111">UART_MF_RAWMODE</a>, <a class="el" href="dev_2uart_8h-source.html#l00216">UART_SETFLOWCONTROL</a>, <a class="el" href="dev_2uart_8h-source.html#l00203">UART_SETLOCALECHO</a>, <a class="el" href="dev_2uart_8h-source.html#l00364">UART_SETRAWMODE</a>, <a class="el" href="dev_2uart_8h-source.html#l00175">UART_SETREADTIMEOUT</a>, <a class="el" href="dev_2uart_8h-source.html#l00109">UART_SETSPEED</a>, <a class="el" href="dev_2uart_8h-source.html#l00162">UART_SETSTATUS</a>, <a class="el" href="dev_2uart_8h-source.html#l00189">UART_SETWRITETIMEOUT</a>, <a class="el" href="at91__us_8h-source.html#l00215">US_BRGR_OFF</a>, <a class="el" href="at91__us_8h-source.html#l00111">US_CLKS</a>, <a class="el" href="at91__us_8h-source.html#l00112">US_CLKS_MCK</a>, <a class="el" href="at91__us_8h-source.html#l00113">US_CLKS_MCK8</a>, <a class="el" href="at91__us_8h-source.html#l00097">US_MR_OFF</a>, and <a class="el" href="at91sam7s_8h-source.html#l00058">USART1_BASE</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdfa27b86eebd5208460d67698f1edf34"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Init" ref="gdfa27b86eebd5208460d67698f1edf34" args="(NUTDEVICE *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91Init           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize asynchronous HDLC device. 
<p>
This function will be called during device registration. It initializes the hardware, registers all required interrupt handlers and initializes all internal data structures used by this driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Identifies the device to initialize.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l00879">879</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="arm_8h-source.html#l00201">_BV</a>, <a class="el" href="ahdlcavr_8c-source.html#l00407">AhdlcRx()</a>, <a class="el" href="memset_8c-source.html#l00088">memset()</a>, <a class="el" href="at91__ahdlc_8c-source.html#l00081">NUT_AHDLC_RECV_DMA_SIZE</a>, <a class="el" href="ahdlcavr_8c-source.html#l00159">NUT_THREAD_AHDLCRXSTACK</a>, <a class="el" href="thread_8h-source.html#l00241">NUT_THREAD_STACK_ADD</a>, <a class="el" href="thread_8h-source.html#l00230">NUT_THREAD_STACK_MULT</a>, <a class="el" href="timer_8c-source.html#l00800">NutGetCpuClock()</a>, <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, <a class="el" href="ihndlr_8c-source.html#l00098">NutRegisterIrqHandler()</a>, <a class="el" href="context__gcc_8c-source.html#l00321">NutThreadCreate()</a>, <a class="el" href="arm_8h-source.html#l00195">outr</a>, <a class="el" href="at91sam7s_8h-source.html#l00087">PDC_RXTDIS</a>, <a class="el" href="at91sam7s_8h-source.html#l00083">PERIPH_PTCR_OFF</a>, <a class="el" href="at91sam7s_8h-source.html#l00076">PERIPH_RCR_OFF</a>, <a class="el" href="at91sam7s_8h-source.html#l00080">PERIPH_RNCR_OFF</a>, <a class="el" href="at91sam7s_8h-source.html#l00079">PERIPH_RNPR_OFF</a>, <a class="el" href="at91sam7s_8h-source.html#l00075">PERIPH_RPR_OFF</a>, <a class="el" href="at91__pmc_8h-source.html#l00103">PMC_PCER</a>, <a class="el" href="at91__ahdlc_8c-source.html#l00089">SIG_UART</a>, <a class="el" href="at91__us_8h-source.html#l00217">US1_BRGR</a>, <a class="el" href="at91__us_8h-source.html#l00071">US1_CR</a>, <a class="el" href="at91sam7s_8h-source.html#l00129">US1_ID</a>, <a class="el" href="at91__us_8h-source.html#l00161">US1_IDR</a>, <a class="el" href="at91__us_8h-source.html#l00099">US1_MR</a>, <a class="el" href="at91__us_8h-source.html#l00139">US_CHMODE_NORMAL</a>, <a class="el" href="at91__us_8h-source.html#l00121">US_CHRL_8</a>, <a class="el" href="at91__ahdlc_8c-source.html#l00091">US_GPIO_PINS</a>, <a class="el" href="at91__us_8h-source.html#l00134">US_NBSTOP_1</a>, <a class="el" href="at91__us_8h-source.html#l00130">US_PAR_NO</a>, <a class="el" href="at91__us_8h-source.html#l00072">US_RSTRX</a>, <a class="el" href="at91__us_8h-source.html#l00073">US_RSTTX</a>, <a class="el" href="at91__us_8h-source.html#l00075">US_RXDIS</a>, <a class="el" href="at91__us_8h-source.html#l00077">US_TXDIS</a>, and <a class="el" href="at91sam7s_8h-source.html#l00058">USART1_BASE</a>.</p>

</div>
</div><p>
<a class="anchor" name="gba4aefd965ac68263cfa5395c8968f6c"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Read" ref="gba4aefd965ac68263cfa5395c8968f6c" args="(NUTFILE *fp, void *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91Read           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read from the asynchronous HDLC device. 
<p>
This function is called by the low level input routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#0b784cc08be2375571b449ebcb2663db" title="Read from device.">_NUTDEVICE::dev_read</a> entry.<p>
The function may block the calling thread until at least one character has been received or a timeout occurs.<p>
It is recommended to set a proper read timeout with software handshake. In this case a timeout may occur, if the communication peer lost our last XON character. The application may then use ioctl() to disable the receiver and do the read again. This will send out another XON.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct___n_u_t_f_i_l_e.html">_NUTFILE</a> structure, obtained by a previous call to AhdlcOpen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the buffer that receives the data. If zero, then all characters in the input buffer will be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Maximum number of bytes to read.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read, which may be less than the number of bytes specified. A return value of -1 indicates an error, while zero is returned in case of a timeout. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l00982">982</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9d948ff25fca454107e921777c7d66d2"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Put" ref="g9d948ff25fca454107e921777c7d66d2" args="(NUTDEVICE *dev, CONST void *buffer, int len, int pflg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91Put           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pflg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to the asynchronous HDLC device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Pointer to a previously registered NUTDEVICE structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer the data to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of data bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pflg</em>&nbsp;</td><td>If this flag is set, then the buffer is located in program space.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written. In case of a write timeout, this may be less than the specified length. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l01022">1022</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="arm_8h-source.html#l00143">CONST</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, <a class="el" href="arm_8h-source.html#l00195">outr</a>, <a class="el" href="arm_8h-source.html#l00155">PRG_RDB</a>, <a class="el" href="at91__us_8h-source.html#l00157">US1_IER</a>, and <a class="el" href="at91__us_8h-source.html#l00168">US_TXRDY</a>.</p>

<p>Referenced by <a class="el" href="at91__ahdlc_8c-source.html#l01073">AhdlcAt91Write()</a>, and <a class="el" href="at91__ahdlc_8c-source.html#l01099">AhdlcAt91Write_P()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdb50c3ce74b373bee474d1e0b3275e90"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Write" ref="gdb50c3ce74b373bee474d1e0b3275e90" args="(NUTFILE *fp, CONST void *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91Write           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to the asynchronous HDLC device. 
<p>
This function is called by the low level output routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#f4d266bf15c47743230962d9b960d24c">_NUTDEVICE::dev_write</a> entry.<p>
The function may block the calling thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct___n_u_t_f_i_l_e.html" title="File structure.">_NUTFILE</a> structure, obtained by a previous call to AhldcOpen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the data to be written. If zero, then the output buffer will be flushed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to write.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written, which may be less than the number of bytes specified if a timeout occured. A return value of -1 indicates an error. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l01073">1073</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="at91__ahdlc_8c-source.html#l01022">AhdlcAt91Put()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0fb0cb74853d071540e3ba8e65dc63a1"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Write_P" ref="g0fb0cb74853d071540e3ba8e65dc63a1" args="(NUTFILE *fp, PGM_P buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91Write_P           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to the asynchronous HDLC device. 
<p>
Similar to AhdlcWrite() except that the data is located in program memory.<p>
This function is called by the low level output routines of the <a class="el" href="group__xg_crt_lowio.html#xrCrtLowio">C runtime library</a>, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#d8372c14180f06a336eafc0eb7683c8a" title="Write to device.">_NUTDEVICE::dev_write_P</a> entry.<p>
The function may block the calling thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a NUTFILE structure, obtained by a previous call to AhdlcOpen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the data in program space to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to write.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written, which may be less than the number of bytes specified if a timeout occured. A return value of -1 indicates an error. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l01099">1099</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="at91__ahdlc_8c-source.html#l01022">AhdlcAt91Put()</a>, and <a class="el" href="arm_8h-source.html#l00143">CONST</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9cdbdf33ba1fc4e8a5951d7205a0ba7a"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Open" ref="g9cdbdf33ba1fc4e8a5951d7205a0ba7a" args="(NUTDEVICE *dev, CONST char *name, int mode, int acc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUTFILE* AhdlcAt91Open           </td>
          <td>(</td>
          <td class="paramtype">NUTDEVICE *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONST char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>acc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the asynchronous HDLC device. 
<p>
This function is called by the low level open routine of the C runtime library, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#dcb423014f04b6ff69e5102291605adf" title="Open a device or file.">_NUTDEVICE::dev_open</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Pointer to the NUTDEVICE structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Ignored, should point to an empty string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Operation mode. Any of the following values may be or-ed:<ul>
<li><a class="el" href="group__xg_crt_lowio.html#g166a079a4990ddeb0a32475728bbacd0">_O_BINARY</a></li><li><a class="el" href="group__xg_crt_lowio.html#g4d457d93039cb26f27461c4af5868309">_O_RDONLY</a></li><li><a class="el" href="group__xg_crt_lowio.html#gc58f7734ab4dd8ae25bda2fba713ea56">_O_WRONLY</a> </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acc</em>&nbsp;</td><td>Ignored, should be zero.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to a NUTFILE structure if successful or NUTFILE_EOF otherwise. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l01120">1120</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, <a class="el" href="file_8h-source.html#l00088">NUTFILE_EOF</a>, <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, <a class="el" href="ihndlr_8c-source.html#l00121">NutIrqEnable()</a>, <a class="el" href="arm_8h-source.html#l00195">outr</a>, <a class="el" href="at91sam7s_8h-source.html#l00086">PDC_RXTEN</a>, <a class="el" href="at91sam7s_8h-source.html#l00083">PERIPH_PTCR_OFF</a>, <a class="el" href="at91__ahdlc_8c-source.html#l00089">SIG_UART</a>, <a class="el" href="at91__ahdlc_8c-source.html#l00087">UART_RECEIVER_TIMEOUT</a>, <a class="el" href="at91__us_8h-source.html#l00071">US1_CR</a>, <a class="el" href="at91__us_8h-source.html#l00157">US1_IER</a>, <a class="el" href="at91__us_8h-source.html#l00224">US1_RTOR</a>, <a class="el" href="at91__us_8h-source.html#l00170">US_ENDRX</a>, <a class="el" href="at91__us_8h-source.html#l00177">US_RXBUFF</a>, <a class="el" href="at91__us_8h-source.html#l00074">US_RXEN</a>, <a class="el" href="at91__us_8h-source.html#l00081">US_STTTO</a>, <a class="el" href="at91__us_8h-source.html#l00175">US_TIMEOUT</a>, <a class="el" href="at91__us_8h-source.html#l00076">US_TXEN</a>, and <a class="el" href="at91sam7s_8h-source.html#l00058">USART1_BASE</a>.</p>

</div>
</div><p>
<a class="anchor" name="g28455b93bc5ead8fddafbfc02da2d6ce"></a><!-- doxytag: member="at91_ahdlc.c::AhdlcAt91Close" ref="g28455b93bc5ead8fddafbfc02da2d6ce" args="(NUTFILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AhdlcAt91Close           </td>
          <td>(</td>
          <td class="paramtype">NUTFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the asynchronous HDLC device. 
<p>
This function is called by the low level close routine of the C runtime library, using the <a class="el" href="struct___n_u_t_d_e_v_i_c_e.html#8fd2505be5a63e619a059523eba40c57" title="Close a device or file.">_NUTDEVICE::dev_close</a> entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct___n_u_t_f_i_l_e.html" title="File structure.">_NUTFILE</a> structure, obtained by a previous call to <a class="el" href="group__xg_usart.html#geb1a110892efd2c8c1c40d9a1602958a" title="Open an USART device.">UsartOpen()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or -1 otherwise.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>We may support shared open and use dev_irq as an open counter. </dd></dl>

<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l01160">1160</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

<p>References <a class="el" href="file_8h-source.html#l00088">NUTFILE_EOF</a>, and <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g2055414d977913bf74d19aaa8519fe3f"></a><!-- doxytag: member="ahdlc0.c::devAhdlc0" ref="g2055414d977913bf74d19aaa8519fe3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUTDEVICE <a class="el" href="group__xg_ahdlc_avr.html#g2055414d977913bf74d19aaa8519fe3f">devAhdlc0</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    0,                          
    {<span class="charliteral">'u'</span>, <span class="charliteral">'a'</span>, <span class="charliteral">'r'</span>, <span class="charliteral">'t'</span>, <span class="charliteral">'0'</span>, 0, 0, 0, 0},      
    <a class="code" href="group__xg_device.html#g161b2f2b0cbc3449e4cd03702e704481" title="Character stream device.">IFTYP_CHAR</a>,                 
    0,                          
    0,                          
    0,                          
    &amp;dcb_ahdlc,                 
    <a class="code" href="group__xg_ahdlc_avr.html#gb82851594ae03aa1f852037435288420" title="Initialize asynchronous HDLC device.">AhdlcAvrInit</a>,               
    <a class="code" href="group__xg_ahdlc_avr.html#ge1493fe9d0ae191af622b1f3d42441ef" title="Perform on-chip UART control functions.">AhdlcAvrIOCtl</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#ge1a62da30e9d1821a97a42c757be8358" title="Read from the asynchronous HDLC device.">AhdlcAvrRead</a>,               
    <a class="code" href="group__xg_ahdlc_avr.html#g6658a32c5b87c6341b4ccd91f2e2b853" title="Write to the asynchronous HDLC device.">AhdlcAvrWrite</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#g33edc97cae8b172b0e3ccb2e2ede4864" title="Write to the asynchronous HDLC device.">AhdlcAvrWrite_P</a>,            
    <a class="code" href="group__xg_ahdlc_avr.html#g14922325c9ea0499e4215cfb5ee89cea" title="Open the asynchronous HDLC device.">AhdlcAvrOpen</a>,               
    <a class="code" href="group__xg_ahdlc_avr.html#g6d1fc092de41db6067e61771c1f21943" title="Close the asynchronous HDLC device.">AhdlcAvrClose</a>,              
    0                           
}
</pre></div>Device information structure. 
<p>
A pointer to this structure must be passed to <a class="el" href="group__xg_device.html#g0d73e3153bf9f210194bd862d9b91c61" title="Register and initialize a device.">NutRegisterDevice()</a> to bind this device driver to the Nut/OS kernel. 
<p>Definition at line <a class="el" href="ahdlc0_8c-source.html#l00062">62</a> of file <a class="el" href="ahdlc0_8c-source.html">ahdlc0.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gda2d8862571cf916513439d0619bd69d"></a><!-- doxytag: member="ahdlc1.c::devAhdlc1" ref="gda2d8862571cf916513439d0619bd69d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUTDEVICE <a class="el" href="group__xg_ahdlc_avr.html#gda2d8862571cf916513439d0619bd69d">devAhdlc1</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    0,                          
    {<span class="charliteral">'u'</span>, <span class="charliteral">'a'</span>, <span class="charliteral">'r'</span>, <span class="charliteral">'t'</span>, <span class="charliteral">'1'</span>, 0, 0, 0, 0},      
    <a class="code" href="group__xg_device.html#g161b2f2b0cbc3449e4cd03702e704481" title="Character stream device.">IFTYP_CHAR</a>,                 
    1,                          
    0,                          
    0,                          
    &amp;dcb_ahdlc,                 
    <a class="code" href="group__xg_ahdlc_avr.html#gb82851594ae03aa1f852037435288420" title="Initialize asynchronous HDLC device.">AhdlcAvrInit</a>,               
    <a class="code" href="group__xg_ahdlc_avr.html#ge1493fe9d0ae191af622b1f3d42441ef" title="Perform on-chip UART control functions.">AhdlcAvrIOCtl</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#ge1a62da30e9d1821a97a42c757be8358" title="Read from the asynchronous HDLC device.">AhdlcAvrRead</a>,               
    <a class="code" href="group__xg_ahdlc_avr.html#g6658a32c5b87c6341b4ccd91f2e2b853" title="Write to the asynchronous HDLC device.">AhdlcAvrWrite</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#g33edc97cae8b172b0e3ccb2e2ede4864" title="Write to the asynchronous HDLC device.">AhdlcAvrWrite_P</a>,            
    <a class="code" href="group__xg_ahdlc_avr.html#g14922325c9ea0499e4215cfb5ee89cea" title="Open the asynchronous HDLC device.">AhdlcAvrOpen</a>,               
    <a class="code" href="group__xg_ahdlc_avr.html#g6d1fc092de41db6067e61771c1f21943" title="Close the asynchronous HDLC device.">AhdlcAvrClose</a>,              
    0                           
}
</pre></div>Device information structure. 
<p>
A pointer to this structure must be passed to <a class="el" href="group__xg_device.html#g0d73e3153bf9f210194bd862d9b91c61" title="Register and initialize a device.">NutRegisterDevice()</a> to bind this device driver to the Nut/OS kernel. 
<p>Definition at line <a class="el" href="ahdlc1_8c-source.html#l00062">62</a> of file <a class="el" href="ahdlc1_8c-source.html">ahdlc1.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gda2d8862571cf916513439d0619bd69d"></a><!-- doxytag: member="at91_ahdlc.c::devAhdlc1" ref="gda2d8862571cf916513439d0619bd69d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUTDEVICE <a class="el" href="group__xg_ahdlc_avr.html#gda2d8862571cf916513439d0619bd69d">devAhdlc1</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    0,                          
    {<span class="charliteral">'u'</span>, <span class="charliteral">'a'</span>, <span class="charliteral">'r'</span>, <span class="charliteral">'t'</span>, <span class="charliteral">'1'</span>, 0, 0, 0, 0},      
    <a class="code" href="group__xg_device.html#g161b2f2b0cbc3449e4cd03702e704481" title="Character stream device.">IFTYP_CHAR</a>,                 
    1,                          
    0,                          
    0,                          
    &amp;dcb_ahdlc,                 
    <a class="code" href="group__xg_ahdlc_avr.html#gdfa27b86eebd5208460d67698f1edf34" title="Initialize asynchronous HDLC device.">AhdlcAt91Init</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#g5cc7ba613a1788ffe7096bb3280ce043" title="Perform on-chip UART control functions.">AhdlcAt91IOCtl</a>,             
    <a class="code" href="group__xg_ahdlc_avr.html#gba4aefd965ac68263cfa5395c8968f6c" title="Read from the asynchronous HDLC device.">AhdlcAt91Read</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#gdb50c3ce74b373bee474d1e0b3275e90" title="Write to the asynchronous HDLC device.">AhdlcAt91Write</a>,             
    <a class="code" href="group__xg_ahdlc_avr.html#g9cdbdf33ba1fc4e8a5951d7205a0ba7a" title="Open the asynchronous HDLC device.">AhdlcAt91Open</a>,              
    <a class="code" href="group__xg_ahdlc_avr.html#g28455b93bc5ead8fddafbfc02da2d6ce" title="Close the asynchronous HDLC device.">AhdlcAt91Close</a>,             
    0                           
}
</pre></div>Device information structure. 
<p>
A pointer to this structure must be passed to <a class="el" href="group__xg_device.html#g0d73e3153bf9f210194bd862d9b91c61" title="Register and initialize a device.">NutRegisterDevice()</a> to bind this device driver to the Nut/OS kernel. 
<p>Definition at line <a class="el" href="at91__ahdlc_8c-source.html#l00108">108</a> of file <a class="el" href="at91__ahdlc_8c-source.html">at91_ahdlc.c</a>.</p>

</div>
</div><p>
</div>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2007 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
