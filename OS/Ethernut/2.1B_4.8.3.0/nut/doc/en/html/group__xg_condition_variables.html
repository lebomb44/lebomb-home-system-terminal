<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
    <link href="nut_entabs.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Condition Variables<br>
<small>
[<a class="el" href="group__xg_app_sugar.html">Application Candies</a>]</small>
</h1>Condition variable support.  
<a href="#_details">More...</a>
<p>

<p>
<div class="dynheader">
Collaboration diagram for Condition Variables:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__xg_condition_variables.png" border="0" alt="" usemap="#group____xg__condition__variables_map">
<map name="group____xg__condition__variables_map">
<area shape="rect" href="group__xg_app_sugar.html" title="In order to keep the kernel clean and small, it uses very basic functions only:." alt="Application Candies" coords="19,5,144,26"></map></td></tr></table></center>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___c_o_n_d_i_t_i_o_n.html">CONDITION</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Condition variable.  <a href="struct___c_o_n_d_i_t_i_o_n.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">CONDITION&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#gf1cfdb6364b398a4da590a852a0ec342">NutConditionInit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new condition variable.  <a href="#gf1cfdb6364b398a4da590a852a0ec342"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#g8d1f7367d8ce51a8739b07592417dcb5">NutConditionLock</a> (CONDITION cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks the condition mutex.  <a href="#g8d1f7367d8ce51a8739b07592417dcb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#g65f371988c64894cc98531e868b592f0">NutConditionUnlock</a> (CONDITION cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unocks the condition mutex.  <a href="#g65f371988c64894cc98531e868b592f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#g64698b737533d2b1bf2b39ab7c643a84">NutConditionWait</a> (CONDITION cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until this thread is woken up on cond.  <a href="#g64698b737533d2b1bf2b39ab7c643a84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#gdd39ad4bbc63d6cd92bdf6fe1ea15246">NutConditionSignal</a> (CONDITION cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If threads are waiting for cond, exactly one of them is woken up.  <a href="#gdd39ad4bbc63d6cd92bdf6fe1ea15246"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#ge400b5be5cc37a2158591bdfe0cbd3ee">NutConditionBroadcast</a> (CONDITION cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If threads are waiting for cond, all of them are woken up.  <a href="#ge400b5be5cc37a2158591bdfe0cbd3ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#g67eee5fb05340ece4163ce1ce1e78bfa">NutConditionFree</a> (CONDITION *cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the ressources used by this condition variable.  <a href="#g67eee5fb05340ece4163ce1ce1e78bfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_condition_variables.html#g55fe4a70a188bbe2be45d2a87b842dbb">NutConditionTimedWait</a> (CONDITION cond, <a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> abs_ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until this thread is woken up on cond but not longer than until the time specified by abs_ms.  <a href="#g55fe4a70a188bbe2be45d2a87b842dbb"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Condition variable support. 
<p>
To avoid entering a busy waiting state, threads must be able to signal each other about events of interest. This capability is implemented as condition variables. When a function requires a particular condition to be true before it can proceed, it waits on an associated condition variable. By waiting, it gives up the lock and is removed from the set of runnable threads. Any thread that subsequently causes the condition to be true may then use the condition variable to notify a thread waiting for the condition. A thread that has been notified regains the lock and can proceed.<p>
As an example look to the following code:<p>
<div class="fragment"><pre class="fragment"> CONDITION cond = NULL;
 <span class="keywordtype">int</span> *current_data = NULL;

 <span class="keywordtype">void</span> push_data (<span class="keywordtype">int</span> *data)
 {
     <a class="code" href="group__xg_condition_variables.html#g8d1f7367d8ce51a8739b07592417dcb5" title="Locks the condition mutex.">NutConditionLock</a>(cond);
     current_data = data;
     NutSonditionSignal(cond);
     <a class="code" href="group__xg_condition_variables.html#g65f371988c64894cc98531e868b592f0" title="Unocks the condition mutex.">NutConditionUnlock</a>(cond);
 }

 <span class="keywordtype">int</span>* pop_data (<span class="keywordtype">void</span>)
 {
     <span class="keywordtype">int</span>* data;

     <a class="code" href="group__xg_condition_variables.html#g8d1f7367d8ce51a8739b07592417dcb5" title="Locks the condition mutex.">NutConditionLock</a>(cond);
     <span class="keywordflow">while</span> (!current_data) {
         g_cond_wait(cond);
     }
     data = current_data;
     current_data = NULL;
     <a class="code" href="group__xg_condition_variables.html#g65f371988c64894cc98531e868b592f0" title="Unocks the condition mutex.">NutConditionUnlock</a>(cond);
     <span class="keywordflow">return</span> data;
 }
</pre></div> <hr><h2>Function Documentation</h2>
<a class="anchor" name="gf1cfdb6364b398a4da590a852a0ec342"></a><!-- doxytag: member="condition.h::NutConditionInit" ref="gf1cfdb6364b398a4da590a852a0ec342" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CONDITION NutConditionInit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new condition variable. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Handle of the condition variable, NULL if not enough memory available </dd></dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00066">66</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="heap_8h-source.html#l00085">NutHeapAlloc</a>, and <a class="el" href="mutex_8c-source.html#l00080">NutMutexInit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8d1f7367d8ce51a8739b07592417dcb5"></a><!-- doxytag: member="condition.h::NutConditionLock" ref="g8d1f7367d8ce51a8739b07592417dcb5" args="(CONDITION cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutConditionLock           </td>
          <td>(</td>
          <td class="paramtype">CONDITION&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks the condition mutex. 
<p>
To avoid the "lost wakeup" bug it is important to always lock the condition before modifying the condition or signalling the condition variable<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>The condition to be locked </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00085">85</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="mutex_8c-source.html#l00096">NutMutexLock()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g65f371988c64894cc98531e868b592f0"></a><!-- doxytag: member="condition.h::NutConditionUnlock" ref="g65f371988c64894cc98531e868b592f0" args="(CONDITION cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutConditionUnlock           </td>
          <td>(</td>
          <td class="paramtype">CONDITION&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unocks the condition mutex. 
<p>
Always unlock the confition after modifying the condition and signalling the condition variable.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>The condition to be unlocked </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00101">101</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="mutex_8c-source.html#l00130">NutMutexUnlock()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g64698b737533d2b1bf2b39ab7c643a84"></a><!-- doxytag: member="condition.h::NutConditionWait" ref="g64698b737533d2b1bf2b39ab7c643a84" args="(CONDITION cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutConditionWait           </td>
          <td>(</td>
          <td class="paramtype">CONDITION&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until this thread is woken up on cond. 
<p>
The condition is unlocked before falling asleep and locked again before resuming.<p>
It is important to use the <a class="el" href="group__xg_condition_variables.html#g64698b737533d2b1bf2b39ab7c643a84" title="Waits until this thread is woken up on cond.">NutConditionWait()</a> and <a class="el" href="group__xg_condition_variables.html#g55fe4a70a188bbe2be45d2a87b842dbb" title="Waits until this thread is woken up on cond but not longer than until the time specified...">NutConditionTimedWait()</a> functions only inside a loop which checks for the condition to be true. It is not guaranteed that the waiting thread will find the condition fulfilled after it wakes up, even if the signaling thread left the condition in that state: another thread may have altered the condition before the waiting thread got the chance to be woken up, even if the condition itself is protected by locking with NutConditionLock.<p>
Always lock the condition before entering the above mentioned check loop and always unlock the condition after successfully leaving the loop and processing the data you wait for.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>The condition to wait on.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on error </dd></dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00130">130</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="event_8h-source.html#l00128">NUT_WAIT_INFINITE</a>, <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="mutex_8c-source.html#l00096">NutMutexLock()</a>, and <a class="el" href="mutex_8c-source.html#l00130">NutMutexUnlock()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdd39ad4bbc63d6cd92bdf6fe1ea15246"></a><!-- doxytag: member="condition.h::NutConditionSignal" ref="gdd39ad4bbc63d6cd92bdf6fe1ea15246" args="(CONDITION cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutConditionSignal           </td>
          <td>(</td>
          <td class="paramtype">CONDITION&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If threads are waiting for cond, exactly one of them is woken up. 
<p>
Call this function after you fullfilled the condition. The conditon should be locked befor fulfilling the condition should not be unlocked before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>The condition to signal </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 on error. Otherwise the number of woken up threads. </dd></dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00193">193</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00454">NutEventPost()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge400b5be5cc37a2158591bdfe0cbd3ee"></a><!-- doxytag: member="condition.h::NutConditionBroadcast" ref="ge400b5be5cc37a2158591bdfe0cbd3ee" args="(CONDITION cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutConditionBroadcast           </td>
          <td>(</td>
          <td class="paramtype">CONDITION&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If threads are waiting for cond, all of them are woken up. 
<p>
Call this function after you fullfilled the condition. The conditon should be locked befor fulfilling the condition should not be unlocked before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>The condition to signal </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 on error. Otherwise the number of woken up threads. </dd></dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00211">211</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00533">NutEventBroadcast()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g67eee5fb05340ece4163ce1ce1e78bfa"></a><!-- doxytag: member="condition.h::NutConditionFree" ref="g67eee5fb05340ece4163ce1ce1e78bfa" args="(CONDITION *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutConditionFree           </td>
          <td>(</td>
          <td class="paramtype">CONDITION *&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the ressources used by this condition variable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00222">222</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="heap_8h-source.html#l00087">NutHeapFree</a>, and <a class="el" href="mutex_8c-source.html#l00147">NutMutexDestroy()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g55fe4a70a188bbe2be45d2a87b842dbb"></a><!-- doxytag: member="condition.c::NutConditionTimedWait" ref="g55fe4a70a188bbe2be45d2a87b842dbb" args="(CONDITION cond, uint32_t abs_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutConditionTimedWait           </td>
          <td>(</td>
          <td class="paramtype">CONDITION&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>abs_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until this thread is woken up on cond but not longer than until the time specified by abs_ms. 
<p>
The condition is unlocked before falling asleep and locked again before resuming.<p>
It is important to use the <a class="el" href="group__xg_condition_variables.html#g64698b737533d2b1bf2b39ab7c643a84" title="Waits until this thread is woken up on cond.">NutConditionWait()</a> and <a class="el" href="group__xg_condition_variables.html#g55fe4a70a188bbe2be45d2a87b842dbb" title="Waits until this thread is woken up on cond but not longer than until the time specified...">NutConditionTimedWait()</a> functions only inside a loop which checks for the condition to be true. It is not guaranteed that the waiting thread will find the condition fulfilled after it wakes up, even if the signaling thread left the condition in that state: another thread may have altered the condition before the waiting thread got the chance to be woken up, even if the condition itself is protected by locking with NutConditionLock.<p>
Always lock the condition before entering the above mentioned check loop and always unlock the condition after successfully leaving the loop and processing the data you wait for.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>The condition to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abs_ms</em>&nbsp;</td><td>Absolute time in ms to longest wait for. Use <a class="el" href="group__xg_timer.html#gc1887264221d66b13d1e86d034227f1c" title="Return the milliseconds counter value.">NutGetMillis()</a> to obtain the current time and add your desired offset. Overflows are handled correct. At longest you can wait 2147483648ms</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on error or timeout </dd></dl>

<p>Definition at line <a class="el" href="condition_8c-source.html#l00167">167</a> of file <a class="el" href="condition_8c-source.html">condition.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="timer_8c-source.html#l00734">NutGetMillis()</a>, <a class="el" href="mutex_8c-source.html#l00096">NutMutexLock()</a>, and <a class="el" href="mutex_8c-source.html#l00130">NutMutexUnlock()</a>.</p>

</div>
</div><p>
</div>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2007 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
