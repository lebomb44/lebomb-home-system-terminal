<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Nut/OS API</title>
    <link href="nut_en.css" rel="stylesheet" type="text/css">
    <link href="nut_entabs.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Event Management<br>
<small>
[<a class="el" href="group__xg_nut_o_s.html">Nut/OS API</a>]</small>
</h1>Thread synchronization support.  
<a href="#_details">More...</a>
<p>

<p>
<div class="dynheader">
Collaboration diagram for Event Management:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__xg_event.png" border="0" alt="" usemap="#group____xg__event_map">
<map name="group____xg__event_map">
<area shape="rect" href="group__xg_nut_o_s.html" title="Operating System API." alt="Nut/OS API" coords="19,5,99,26"></map></td></tr></table></center>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#g65e5b23d1a8f35862480021738a7ecbc">SIGNALED</a>&nbsp;&nbsp;&nbsp;((void *)-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaled state definition.  <a href="#g65e5b23d1a8f35862480021738a7ecbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#gee7b86caed1918238b71ffbff86e1eb7">NUT_WAIT_INFINITE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Infinite waiting time definition.  <a href="#gee7b86caed1918238b71ffbff86e1eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#gc52b53066d7486072b4e1ace5b4c6f3b">NutEventPostFromIrq</a>(qp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an event to a specified queue from interrupt context.  <a href="#gc52b53066d7486072b4e1ace5b4c6f3b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#gaa944c4484d068bdacd8220b7e081302">NutEventTimeout</a> (<a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> timer, void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timer callback in case of event timeout.  <a href="#gaa944c4484d068bdacd8220b7e081302"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#g79af18e0842286182af7c5b647526ce5">NutEventWait</a> (volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *qhp, <a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for an event in a specified queue.  <a href="#g79af18e0842286182af7c5b647526ce5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#gc836d5fc78018d8d079cc9d21a2383b9">NutEventWaitNext</a> (volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *qhp, <a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a> ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a new event in a specified queue.  <a href="#gc836d5fc78018d8d079cc9d21a2383b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#g129d2de44ddf083f252d0754fc45d9d3">NutEventPostAsync</a> (volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously post an event to a specified queue.  <a href="#g129d2de44ddf083f252d0754fc45d9d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#gd519c6b1469621d2b3909fe58d1ac40b">NutEventPost</a> (volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an event to a specified queue.  <a href="#gd519c6b1469621d2b3909fe58d1ac40b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#g21d9c3cc7ae2c9bddfb130b54b081076">NutEventBroadcastAsync</a> (volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously broadcast an event to a specified queue.  <a href="#g21d9c3cc7ae2c9bddfb130b54b081076"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xg_event.html#g575628f89864beb575a161f10f3de62c">NutEventBroadcast</a> (volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *qhp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast an event to a specified queue.  <a href="#g575628f89864beb575a161f10f3de62c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Thread synchronization support. 
<p>
Threads may wait for events from other threads or interrupts or may post or broadcast events to other threads.<p>
Waiting threads line up in priority ordered queues, so more than one thread may wait for the same event. A waiting queue is a simple linked list of waiting threads.<p>
Events are posted to a waiting queue, moving the <a class="el" href="group__xg_thread.html#xrThread">thread</a> from waiting (sleeping) state to ready-to-run state. A running thread may also broadcast an event to a specified queue, waking up all threads on that queue.<p>
Usually a woken up thread takes over the CPU, if it's priority is equal or higher than the currently running thread. However, events can be posted asynchronously, in which case the posting thread continues to run.<p>
Interrupt can also post events, but have to use the specific function <a class="el" href="group__xg_event.html#gc52b53066d7486072b4e1ace5b4c6f3b" title="Post an event to a specified queue from interrupt context.">NutEventPostFromIrq()</a>. <hr><h2>Define Documentation</h2>
<a class="anchor" name="g65e5b23d1a8f35862480021738a7ecbc"></a><!-- doxytag: member="event.h::SIGNALED" ref="g65e5b23d1a8f35862480021738a7ecbc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNALED&nbsp;&nbsp;&nbsp;((void *)-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signaled state definition. 
<p>
The root of an event queue is set to this value if an event is posted to an empty queue. As this may happen during interrupts, the root of an event queue must be considered volatile.<p>
Timer handles in the THREADINFO structure are set to this value if a timeout occured while waiting for an event. 
<p>Definition at line <a class="el" href="event_8h-source.html#l00120">120</a> of file <a class="el" href="event_8h-source.html">event.h</a>.</p>

<p>Referenced by <a class="el" href="osdebug_8c-source.html#l00155">NutDumpThreadList()</a>, <a class="el" href="osdebug_8c-source.html#l00116">NutDumpThreadQueue()</a>, <a class="el" href="event_8c-source.html#l00486">NutEventBroadcastAsync()</a>, <a class="el" href="event_8c-source.html#l00384">NutEventPostAsync()</a>, <a class="el" href="event_8c-source.html#l00196">NutEventTimeout()</a>, <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="event_8c-source.html#l00350">NutEventWaitNext()</a>, <a class="el" href="semaphore_8c-source.html#l00141">NutSemDestroy()</a>, <a class="el" href="os_2thread_8c-source.html#l00289">NutThreadAddPriQueue()</a>, <a class="el" href="os_2thread_8c-source.html#l00341">NutThreadRemoveQueue()</a>, <a class="el" href="os_2thread_8c-source.html#l00382">NutThreadResume()</a>, <a class="el" href="twif_8c-source.html#l00535">TwMasterTransact()</a>, <a class="el" href="twif_8c-source.html#l00653">TwSlaveListen()</a>, and <a class="el" href="twif_8c-source.html#l00727">TwSlaveRespond()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gee7b86caed1918238b71ffbff86e1eb7"></a><!-- doxytag: member="event.h::NUT_WAIT_INFINITE" ref="gee7b86caed1918238b71ffbff86e1eb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUT_WAIT_INFINITE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Infinite waiting time definition. 
<p>
Applications should use this value to disable timeout monitoring while waiting for an event. 
<p>Definition at line <a class="el" href="event_8h-source.html#l00128">128</a> of file <a class="el" href="event_8h-source.html">event.h</a>.</p>

<p>Referenced by <a class="el" href="spibus0at91_8c-source.html#l00236">At91SpiBus0Deselect()</a>, <a class="el" href="spibus0at91_8c-source.html#l00296">At91SpiBus0Transfer()</a>, <a class="el" href="atcan_8c-source.html#l00551">AtCanOutput()</a>, <a class="el" href="spibus0avr_8c-source.html#l00477">AvrSpiBus0Deselect()</a>, <a class="el" href="spibus0avr_8c-source.html#l00255">AvrSpiBus0Transfer()</a>, <a class="el" href="sja1000_8c-source.html#l00576">CAN_Tx()</a>, <a class="el" href="cy2239x_8c-source.html#l00199">Cy2239xGetDivider()</a>, <a class="el" href="cy2239x_8c-source.html#l00506">Cy2239xGetFreq()</a>, <a class="el" href="cy2239x_8c-source.html#l00124">Cy2239xGetPll()</a>, <a class="el" href="cy2239x_8c-source.html#l00328">Cy2239xPllEnable()</a>, <a class="el" href="cy2239x_8c-source.html#l00383">Cy2239xPllGetFreq()</a>, <a class="el" href="cy2239x_8c-source.html#l00440">Cy2239xPllSetFreq()</a>, <a class="el" href="cy2239x_8c-source.html#l00262">Cy2239xSetDivider()</a>, <a class="el" href="cy2239x_8c-source.html#l00159">Cy2239xSetPll()</a>, <a class="el" href="ds1307rtc_8c-source.html#l00199">DS1307RamWrite()</a>, <a class="el" href="ds1307rtc_8c-source.html#l00089">DS1307RtcReadRegs()</a>, <a class="el" href="ds1307rtc_8c-source.html#l00110">DS1307RtcWrite()</a>, <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>, <a class="el" href="condition_8c-source.html#l00130">NutConditionWait()</a>, <a class="el" href="dhcpc_8c-source.html#l01353">NutDhcpClient()</a>, <a class="el" href="mutex_8c-source.html#l00096">NutMutexLock()</a>, <a class="el" href="pcf8563_8c-source.html#l00083">PcfRtcReadRegs()</a>, <a class="el" href="pcf8563_8c-source.html#l00106">PcfRtcWrite()</a>, <a class="el" href="x12rtc_8c-source.html#l00463">X12EepromRead()</a>, <a class="el" href="x12rtc_8c-source.html#l00488">X12EepromWrite()</a>, <a class="el" href="x12rtc_8c-source.html#l00174">X12RtcReadRegs()</a>, and <a class="el" href="x12rtc_8c-source.html#l00207">X12RtcWrite()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc52b53066d7486072b4e1ace5b4c6f3b"></a><!-- doxytag: member="event.h::NutEventPostFromIrq" ref="gc52b53066d7486072b4e1ace5b4c6f3b" args="(qp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NutEventPostFromIrq          </td>
          <td>(</td>
          <td class="paramtype">qp&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{                                   \
    <span class="keywordflow">if</span> (*qp == 0) {                 \
        *qp = <a class="code" href="group__xg_event.html#g65e5b23d1a8f35862480021738a7ecbc" title="Signaled state definition.">SIGNALED</a>;             \
    }                               \
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*qp != <a class="code" href="group__xg_event.html#g65e5b23d1a8f35862480021738a7ecbc" title="Signaled state definition.">SIGNALED</a>) {     \
        NUTTHREADINFO *tp = (NUTTHREADINFO *)(*qp);    \
        tp-&gt;td_qpec++;              \
    }                               \
}
</pre></div>Post an event to a specified queue from interrupt context. 
<p>
Wake up the thread with the highest priority waiting on the specified queue. This function is explicitly provided for IRQ handlers to wakeup waiting user threads.<p>
Internally a counter is used to keep track of the posted events. This counter will be examined when the currently running thread is ready to release the CPU.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When calling this function, interrupt routines will change the root of an empty event queue to SIGNALED.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qp</em>&nbsp;</td><td>Identifies the queue an event is posted to. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="event_8h-source.html#l00147">147</a> of file <a class="el" href="event_8h-source.html">event.h</a>.</p>

<p>Referenced by <a class="el" href="spibus0at91_8c-source.html#l00260">At91SpiBus0Interrupt()</a>, <a class="el" href="arch_2unix_2os_2nutinit_8c-source.html#l00162">NutUnixThreadYieldHook()</a>, and <a class="el" href="irsony_8c-source.html#l00114">SIG_INTERRUPT4()</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gaa944c4484d068bdacd8220b7e081302"></a><!-- doxytag: member="event.c::NutEventTimeout" ref="gaa944c4484d068bdacd8220b7e081302" args="(HANDLE timer, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NutEventTimeout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a>&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Timer callback in case of event timeout. 
<p>
Applications should not call this function. It is provided as a global to enable debugging code inspecting the callbacks in the timer list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>Handle of the elapsed timeout timer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Handle of an event queue. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00196">196</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="nutdebug_8h-source.html#l00047">NUTASSERT</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, <a class="el" href="os_2thread_8c-source.html#l00289">NutThreadAddPriQueue()</a>, <a class="el" href="os_2thread_8c-source.html#l00275">runQueue</a>, <a class="el" href="event_8h-source.html#l00120">SIGNALED</a>, and <a class="el" href="thread_8h-source.html#l00199">TDS_READY</a>.</p>

<p>Referenced by <a class="el" href="osdebug_8c-source.html#l00205">NutDumpTimerList()</a>, and <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g79af18e0842286182af7c5b647526ce5"></a><!-- doxytag: member="event.c::NutEventWait" ref="g79af18e0842286182af7c5b647526ce5" args="(volatile HANDLE *qhp, uint32_t ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutEventWait           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *&nbsp;</td>
          <td class="paramname"> <em>qhp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for an event in a specified queue. 
<p>
Give up the CPU until another thread or an interrupt routine posts an event to this queue or until a time-out occurs, whichever comes first.<p>
If previously an event had been posted to this queue without any thread waiting, then the thread will not wait for a new event, but may still pass CPU control, if another thread with equal or higher priority is ready to run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>Maximum wait time in milliseconds. To disable timeout, set this parameter to NUT_WAIT_INFINITE.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if event received, -1 on timeout.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Timeout is limited to the granularity of the system timer. </dd></dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00271">271</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="nutdebug_8h-source.html#l00047">NUTASSERT</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="event_8c-source.html#l00196">NutEventTimeout()</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, <a class="el" href="os_2thread_8c-source.html#l00289">NutThreadAddPriQueue()</a>, <a class="el" href="os_2thread_8c-source.html#l00341">NutThreadRemoveQueue()</a>, <a class="el" href="os_2thread_8c-source.html#l00382">NutThreadResume()</a>, <a class="el" href="os_2thread_8c-source.html#l00468">NutThreadYield()</a>, <a class="el" href="timer_8c-source.html#l00584">NutTimerStart()</a>, <a class="el" href="os_2thread_8c-source.html#l00248">runningThread</a>, <a class="el" href="os_2thread_8c-source.html#l00275">runQueue</a>, <a class="el" href="event_8h-source.html#l00120">SIGNALED</a>, <a class="el" href="thread_8h-source.html#l00200">TDS_SLEEP</a>, <a class="el" href="sys_2timer_8h-source.html#l00151">TM_ONESHOT</a>, <a class="el" href="tracer_8h-source.html#l00274">TRACE_ADD_ITEM</a>, and <a class="el" href="tracer_8h-source.html#l00079">TRACE_TAG_THREAD_WAIT</a>.</p>

<p>Referenced by <a class="el" href="at91__ahdlc_8c-source.html#l00982">AhdlcAt91Read()</a>, <a class="el" href="ahdlcavr_8c-source.html#l01168">AhdlcAvrRead()</a>, <a class="el" href="ahdlcavr_8c-source.html#l00407">AhdlcRx()</a>, <a class="el" href="spibus0at91_8c-source.html#l00185">At91SpiBus0Select()</a>, <a class="el" href="spibus0at91_8c-source.html#l00296">At91SpiBus0Transfer()</a>, <a class="el" href="spibus__at91_8c-source.html#l00343">At91SpiBusWait()</a>, <a class="el" href="at91__spi_8c-source.html#l00617">At91SpiTransfer2()</a>, <a class="el" href="atcan_8c-source.html#l00573">AtCanInput()</a>, <a class="el" href="atcan_8c-source.html#l00551">AtCanOutput()</a>, <a class="el" href="spibus0avr_8c-source.html#l00405">AvrSpiBus0Select()</a>, <a class="el" href="spibus0avr_8c-source.html#l00255">AvrSpiBus0Transfer()</a>, <a class="el" href="sja1000_8c-source.html#l00576">CAN_Tx()</a>, <a class="el" href="display_8c-source.html#l00073">Displayer()</a>, <a class="el" href="at91__emac_8c-source.html#l00913">EmacOutput()</a>, <a class="el" href="at91__emac_8c-source.html#l00815">EmacRxThread()</a>, <a class="el" href="fat_8c-source.html#l00433">FATLock()</a>, <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>, <a class="el" href="spibus0gpio_8c-source.html#l00364">GpioSpiBus0Select()</a>, <a class="el" href="events_8c-source.html#l00078">High()</a>, <a class="el" href="ide_8c-source.html#l00227">IDELock()</a>, <a class="el" href="lanc111_8c-source.html#l01264">LancOutput()</a>, <a class="el" href="events_8c-source.html#l00099">Low()</a>, <a class="el" href="events_8c-source.html#l00119">main()</a>, <a class="el" href="mmcard_8c-source.html#l00968">MmCardIOCtl()</a>, <a class="el" href="nicrtl_8c-source.html#l01287">NicRx()</a>, <a class="el" href="ax88796_8c-source.html#l00792">NicRxAsix()</a>, <a class="el" href="lanc111_8c-source.html#l01188">NicRxLanc()</a>, <a class="el" href="spibus__npl_8c-source.html#l00153">NplSpiBusSelect()</a>, <a class="el" href="arpcache_8c-source.html#l00448">NutArpCacheQuery()</a>, <a class="el" href="condition_8c-source.html#l00167">NutConditionTimedWait()</a>, <a class="el" href="condition_8c-source.html#l00130">NutConditionWait()</a>, <a class="el" href="dhcpc_8c-source.html#l01353">NutDhcpClient()</a>, <a class="el" href="event_8c-source.html#l00350">NutEventWaitNext()</a>, <a class="el" href="ir_8c-source.html#l00066">NutIrGet()</a>, <a class="el" href="msg_8c-source.html#l00345">NutMsgQGetMessage()</a>, <a class="el" href="ifconfig_8c-source.html#l00309">NutNetIfConfig2()</a>, <a class="el" href="tcpsock_8c-source.html#l00764">NutTcpReceive()</a>, <a class="el" href="tcpsock_8c-source.html#l00694">NutTcpSend()</a>, <a class="el" href="tcpsm_8c-source.html#l01643">NutTcpSm()</a>, <a class="el" href="tcpsm_8c-source.html#l00831">NutTcpStateActiveOpenEvent()</a>, <a class="el" href="tcpsm_8c-source.html#l00806">NutTcpStatePassiveOpenEvent()</a>, <a class="el" href="udpsock_8c-source.html#l00282">NutUdpReceiveFrom()</a>, <a class="el" href="phatio_8c-source.html#l00169">PhatSectorLoad()</a>, <a class="el" href="wlandrv_8c-source.html#l01087">RxThread()</a>, <a class="el" href="sja1000_8c-source.html#l00308">SJAInput()</a>, <a class="el" href="timers_8c-source.html#l00148">TimerEvent1()</a>, <a class="el" href="timers_8c-source.html#l00160">TimerEvent2()</a>, <a class="el" href="timers_8c-source.html#l00172">TimerEvent3()</a>, <a class="el" href="timers_8c-source.html#l00184">TimerEvent4()</a>, <a class="el" href="tlv320dac_8c-source.html#l00383">Tlv320DacFlush()</a>, <a class="el" href="tlv320dac_8c-source.html#l00404">Tlv320DacWrite()</a>, <a class="el" href="at91__twi_8c-source.html#l00269">TwMasterRegRead()</a>, <a class="el" href="at91__twi_8c-source.html#l00344">TwMasterRegWrite()</a>, <a class="el" href="at91__twi_8c-source.html#l00173">TwMasterTransact()</a>, <a class="el" href="twif_8c-source.html#l00653">TwSlaveListen()</a>, <a class="el" href="twif_8c-source.html#l00727">TwSlaveRespond()</a>, <a class="el" href="uartavr_8c-source.html#l00260">UartAvrFlush()</a>, <a class="el" href="uartavr_8c-source.html#l00182">UartAvrInput()</a>, <a class="el" href="usart_8c-source.html#l00198">UsartRead()</a>, <a class="el" href="spi__vscodec_8c-source.html#l00080">VsCodecWaitReady()</a>, and <a class="el" href="spi__vscodec_8c-source.html#l00552">VsCodecWrite()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc836d5fc78018d8d079cc9d21a2383b9"></a><!-- doxytag: member="event.c::NutEventWaitNext" ref="gc836d5fc78018d8d079cc9d21a2383b9" args="(volatile HANDLE *qhp, uint32_t ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutEventWaitNext           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *&nbsp;</td>
          <td class="paramname"> <em>qhp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#06896e8c53f721507066c079052171f8">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for a new event in a specified queue. 
<p>
Give up the CPU until another thread or an interrupt routine posts an event to this queue or until a time-out occurs, whichever comes first.<p>
This call is similar to <a class="el" href="group__xg_event.html#g79af18e0842286182af7c5b647526ce5" title="Wait for an event in a specified queue.">NutEventWait()</a>, but will ignore the SIGNALED state of the queue. This way, previously posted events to an empty queue are not considered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>Maximum wait time in milliseconds. To disable timeout, set this parameter to NUT_WAIT_INFINITE.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if event received, -1 on timeout.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Timeout is limited to the granularity of the system timer. </dd></dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00350">350</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="nutdebug_8h-source.html#l00047">NUTASSERT</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="event_8c-source.html#l00271">NutEventWait()</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, and <a class="el" href="event_8h-source.html#l00120">SIGNALED</a>.</p>

<p>Referenced by <a class="el" href="tlc16c550_8c-source.html#l00365">AceFlush()</a>, <a class="el" href="tlc16c550_8c-source.html#l00305">AceInput()</a>, <a class="el" href="ide_8c-source.html#l01120">CFChange()</a>, and <a class="el" href="mutex_8c-source.html#l00096">NutMutexLock()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g129d2de44ddf083f252d0754fc45d9d3"></a><!-- doxytag: member="event.c::NutEventPostAsync" ref="g129d2de44ddf083f252d0754fc45d9d3" args="(volatile HANDLE *qhp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutEventPostAsync           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *&nbsp;</td>
          <td class="paramname"> <em>qhp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronously post an event to a specified queue. 
<p>
Wake up the thread with the highest priority waiting on the specified queue. But even if the priority of the woken thread is higher than the current thread's priority, the current one continues running.<p>
If no thread is waiting, then the queue will be set to the SIGNALED state.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Interrupts must not call this function but use <a class="el" href="group__xg_event.html#gc52b53066d7486072b4e1ace5b4c6f3b" title="Post an event to a specified queue from interrupt context.">NutEventPostFromIrq()</a> to post events to specific queues.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is posted to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of threads woken up, either 0 or 1. </dd></dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00384">384</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="nutdebug_8h-source.html#l00047">NUTASSERT</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, <a class="el" href="os_2thread_8c-source.html#l00289">NutThreadAddPriQueue()</a>, <a class="el" href="timer_8c-source.html#l00647">NutTimerStop()</a>, <a class="el" href="os_2thread_8c-source.html#l00275">runQueue</a>, <a class="el" href="event_8h-source.html#l00120">SIGNALED</a>, and <a class="el" href="thread_8h-source.html#l00199">TDS_READY</a>.</p>

<p>Referenced by <a class="el" href="tlc16c550_8c-source.html#l00484">AceIOCtl()</a>, <a class="el" href="event_8c-source.html#l00486">NutEventBroadcastAsync()</a>, <a class="el" href="event_8c-source.html#l00454">NutEventPost()</a>, <a class="el" href="msg_8c-source.html#l00345">NutMsgQGetMessage()</a>, <a class="el" href="msg_8c-source.html#l00157">NutMsgQPost()</a>, <a class="el" href="os_2thread_8c-source.html#l00382">NutThreadResume()</a>, <a class="el" href="phatio_8c-source.html#l00169">PhatSectorLoad()</a>, <a class="el" href="sja1000_8c-source.html#l00284">SJAOutput()</a>, and <a class="el" href="timers_8c-source.html#l00143">TimerCallback()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd519c6b1469621d2b3909fe58d1ac40b"></a><!-- doxytag: member="event.c::NutEventPost" ref="gd519c6b1469621d2b3909fe58d1ac40b" args="(volatile HANDLE *qhp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutEventPost           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *&nbsp;</td>
          <td class="paramname"> <em>qhp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post an event to a specified queue. 
<p>
Wake up the thread with the highest priority waiting on this queue. If the priority of the waiting thread is higher or equal than the current thread's priority, then the current thread is stopped and CPU control is passed to the waiting thread.<p>
If no thread is waiting, the queue will be set to the signaled state.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Interrupts must not call this function but use <a class="el" href="group__xg_event.html#gc52b53066d7486072b4e1ace5b4c6f3b" title="Post an event to a specified queue from interrupt context.">NutEventPostFromIrq()</a> to post events to specific queues.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is posted to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of threads woken up, either 0 or 1. </dd></dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00454">454</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00384">NutEventPostAsync()</a>, and <a class="el" href="os_2thread_8c-source.html#l00468">NutThreadYield()</a>.</p>

<p>Referenced by <a class="el" href="at91__ahdlc_8c-source.html#l00729">AhdlcAt91IOCtl()</a>, <a class="el" href="ahdlcavr_8c-source.html#l00784">AhdlcAvrIOCtl()</a>, <a class="el" href="spibus0at91_8c-source.html#l00236">At91SpiBus0Deselect()</a>, <a class="el" href="spibus0at91_8c-source.html#l00185">At91SpiBus0Select()</a>, <a class="el" href="spibus0avr_8c-source.html#l00477">AvrSpiBus0Deselect()</a>, <a class="el" href="spibus0avr_8c-source.html#l00405">AvrSpiBus0Select()</a>, <a class="el" href="display_8c-source.html#l00206">DisplayEntry()</a>, <a class="el" href="display_8c-source.html#l00186">DisplayMessage()</a>, <a class="el" href="display_8c-source.html#l00145">DisplayStatus()</a>, <a class="el" href="at91__emac_8c-source.html#l00913">EmacOutput()</a>, <a class="el" href="at91__emac_8c-source.html#l00815">EmacRxThread()</a>, <a class="el" href="fat_8c-source.html#l00441">FATFree()</a>, <a class="el" href="fat_8c-source.html#l00449">FATSemaInit()</a>, <a class="el" href="hxcodec_8c-source.html#l00267">FeederThread()</a>, <a class="el" href="spibus0gpio_8c-source.html#l00411">GpioSpiBus0Deselect()</a>, <a class="el" href="spibus0gpio_8c-source.html#l00364">GpioSpiBus0Select()</a>, <a class="el" href="events_8c-source.html#l00078">High()</a>, <a class="el" href="ide_8c-source.html#l00235">IDEFree()</a>, <a class="el" href="ide_8c-source.html#l00243">IDESemaInit()</a>, <a class="el" href="pppsm_8c-source.html#l00434">IpcpClose()</a>, <a class="el" href="pppsm_8c-source.html#l00511">IpcpLowerDown()</a>, <a class="el" href="ipcpin_8c-source.html#l00258">IpcpRxConfAck()</a>, <a class="el" href="ipcpin_8c-source.html#l00104">IpcpRxConfReq()</a>, <a class="el" href="lanc111_8c-source.html#l01264">LancOutput()</a>, <a class="el" href="events_8c-source.html#l00099">Low()</a>, <a class="el" href="events_8c-source.html#l00119">main()</a>, <a class="el" href="mmcard_8c-source.html#l00968">MmCardIOCtl()</a>, <a class="el" href="lanc111_8c-source.html#l01188">NicRxLanc()</a>, <a class="el" href="spibus__npl_8c-source.html#l00190">NplSpiBusDeselect()</a>, <a class="el" href="spibus__npl_8c-source.html#l00153">NplSpiBusSelect()</a>, <a class="el" href="condition_8c-source.html#l00193">NutConditionSignal()</a>, <a class="el" href="mutex_8c-source.html#l00130">NutMutexUnlock()</a>, <a class="el" href="spibus_8c-source.html#l00072">NutRegisterSpiDevice()</a>, <a class="el" href="semaphore_8c-source.html#l00109">NutSemPost()</a>, <a class="el" href="tcpsm_8c-source.html#l01740">NutTcpStateMachine()</a>, <a class="el" href="udpin_8c-source.html#l00158">NutUdpInput()</a>, <a class="el" href="udpsock_8c-source.html#l00530">NutUdpSetSocketError()</a>, <a class="el" href="phatvol_8c-source.html#l00186">PhatVolMount()</a>, <a class="el" href="rawfs_8c-source.html#l00529">RawFsMount()</a>, <a class="el" href="at91__twi_8c-source.html#l00503">TwInit()</a>, <a class="el" href="at91__twi_8c-source.html#l00269">TwMasterRegRead()</a>, <a class="el" href="at91__twi_8c-source.html#l00344">TwMasterRegWrite()</a>, <a class="el" href="at91__twi_8c-source.html#l00173">TwMasterTransact()</a>, <a class="el" href="spi__vscodec_8c-source.html#l00395">VsCodecIOCtl()</a>, <a class="el" href="spi__vscodec_8c-source.html#l00552">VsCodecWrite()</a>, and <a class="el" href="wlandrv_8c-source.html#l01434">wlandrv_Attach()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g21d9c3cc7ae2c9bddfb130b54b081076"></a><!-- doxytag: member="event.c::NutEventBroadcastAsync" ref="g21d9c3cc7ae2c9bddfb130b54b081076" args="(volatile HANDLE *qhp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutEventBroadcastAsync           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *&nbsp;</td>
          <td class="paramname"> <em>qhp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronously broadcast an event to a specified queue. 
<p>
Wake up all threads waiting on this queue. But even if the priority of any woken thread is higher than the current thread's priority, the current one continues running.<p>
In opposite to <a class="el" href="group__xg_event.html#g129d2de44ddf083f252d0754fc45d9d3" title="Asynchronously post an event to a specified queue.">NutEventPostAsync()</a>, the queue will be cleared in any case, even if it is in signaled state. Applications may use this call to make sure, that a queue is cleared before initiating some event triggering action.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is broadcasted to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of threads woken up. </dd></dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00486">486</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="nutdebug_8h-source.html#l00047">NUTASSERT</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00136">NutEnterCritical</a>, <a class="el" href="event_8c-source.html#l00384">NutEventPostAsync()</a>, <a class="el" href="include_2arch_2arm_2atom_8h-source.html#l00147">NutExitCritical</a>, and <a class="el" href="event_8h-source.html#l00120">SIGNALED</a>.</p>

<p>Referenced by <a class="el" href="event_8c-source.html#l00533">NutEventBroadcast()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g575628f89864beb575a161f10f3de62c"></a><!-- doxytag: member="event.c::NutEventBroadcast" ref="g575628f89864beb575a161f10f3de62c" args="(volatile HANDLE *qhp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NutEventBroadcast           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="group__xg_nut_o_s.html#ga8c0374618b33785ccb02f74bcfebc46">HANDLE</a> *&nbsp;</td>
          <td class="paramname"> <em>qhp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Broadcast an event to a specified queue. 
<p>
Wake up all threads waiting on this queue. If the priority of any waiting thread is higher or equal than the current thread's priority, then the current thread is stopped and CPU control is passed to the woken up thread with the highest priority.<p>
In opposite to <a class="el" href="group__xg_event.html#gd519c6b1469621d2b3909fe58d1ac40b" title="Post an event to a specified queue.">NutEventPost()</a>, the queue will be cleared in any case, even if it is in signaled state. Applications may use this call to make sure, that a queue is cleared before initiating some event triggering action.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qhp</em>&nbsp;</td><td>Identifies the queue an event is broadcasted to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of threads woken up. </dd></dl>

<p>Definition at line <a class="el" href="event_8c-source.html#l00533">533</a> of file <a class="el" href="event_8c-source.html">event.c</a>.</p>

<p>References <a class="el" href="event_8c-source.html#l00486">NutEventBroadcastAsync()</a>, and <a class="el" href="os_2thread_8c-source.html#l00468">NutThreadYield()</a>.</p>

<p>Referenced by <a class="el" href="arpcache_8c-source.html#l00393">NutArpCacheUpdate()</a>, <a class="el" href="condition_8c-source.html#l00211">NutConditionBroadcast()</a>, <a class="el" href="dhcpc_8c-source.html#l01353">NutDhcpClient()</a>, <a class="el" href="ifconfig_8c-source.html#l00309">NutNetIfConfig2()</a>, and <a class="el" href="tcpsm_8c-source.html#l01803">NutTcpAbortSocket()</a>.</p>

</div>
</div><p>
</div>
<hr>
<address>
  <small>
    &copy;&nbsp;2000-2007 by egnite Software GmbH - 
    visit <a href="http://www.ethernut.de/">http://www.ethernut.de/</a>
  </small>
</address>
</body>
</html>
